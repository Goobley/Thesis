\chapter{Radiative Transfer with\\Time-Dependent Populations}\label{Chap:TimeDepRt}
%TC:group pycode 0 0
\begin{pycode}[TimeDepRT]
name = 'TimeDepRT'
chRT = texfigure.Manager(
    pytex,
    './02TimeDepRT',
    number=2,
    python_dir='./02TimeDepRT/python',
    fig_dir=   './02TimeDepRT/Figs',
    data_dir=  './Data/02TimeDepRT'
)
\end{pycode}


% \begin{itemize}
%     \item Current problems not solved by RADYN and MS\_RADYN.
%     \item \Lw{}
%     \item \MsLw{}
%     \item Reprocessing RADYN simulations
%     \item Effect of the Lyman lines on \CaLine{} in RHD simulations
%     \item Diagnostic potential of response functions
%     \item Another item - PRD is hard?
% \end{itemize}

Modern Radiation Hydrodynamic (RHD) codes as described in Chap.~\ref{Chap:FlareModelling} are highly complex, and contain many specialised features.
In the following discussion we will focus primarily on \Radyn{}, the most widely used code of its ilk, and show how using additional tools can facilitate new avenues of investigation.

\section{A Brief Dissection of \Radyn{} and a Possible Future of RHD Modelling}\label{Sec:RadynDissection}

\emph{This section is informed by my discussions with Prof. Mats Carlsson of the University of Oslo, experiences using \Radyn{}, and analysis of its source code. It represents my own conclusions from the synthesis of these.}

\Radyn{}'s design closely follows its radiative transfer lineage. Its direct predecessor is the MULTI radiative transfer code \citep{Carlsson1986,Carlsson1992} and many commonalities remain.
NLTE radiative transfer is solved on a per transition basis using an ALI method and linearisation of the resultant kinetic equilibrium equations.
This method solves for the case of non-overlapping lines but includes an underlying background continuum.
This linearisation approach was proven by \citet{SocasNavarro1997} to be effectively equivalent to that of preconditioning for non-overlapping transitions \citep[i.e. MALI,][]{Rybicki1991} for pure radiative transfer problems in the statistical equilibrium case.
Their analysis assumed the use of a local diagonal $\Lambda^*$ operator; \Radyn{}, however, chooses to employ a pentadiagonal $\Lambda^*$ operator to make optimal use of matrix bandwidth needed elsewhere in the program and obtain improved convergence as a result.
It is unlikely that this change in operator significantly affects the conclusions of \citet{SocasNavarro1997}, but the two methods will no longer arrive at exactly equivalent numerical formulations.
\Radyn{} also uses an efficient Feautrier formalism for its formal solver, which solves for both the up- and down-going rays simultaneously but cannot handle both overlapping lines and Doppler shifts.
There are no lines with significant overlap considered in the standard model atoms used in \Radyn{}, and continuum emissivities and opacities rarely change sufficiently over the wavelength range of a line to need to be considered in a wavelength varying sense.
This is likely a fair trade-off for \Radyn{} given the computational benefits it can bring.

The advantage of the linearisation approach applied in \Radyn{} is the ability to directly couple other equations to the RTE and implicitly solve all of these simultaneously and self-consistently.
Taking for example the kinetic equilibrium equation \eqref{Eq:KinEq}, \Radyn{}'s method formulates this expression such that the corrections from both the advection and population transition terms are considered simultaneously.
This is achieved through the use of a Newton-Raphson method, where the Jacobian is computed based on an analytic derivation, including the aforementioned linearisation of the kinetic equilibrium equations.
This same process simultaneously solves for the population updates, heat conduction, hydrodynamics of the system, and the new locations of the dynamic grid \added{points on which the RHD equations are discretised} following the method of \citet{Dorfi1987}.

A significant benefit of this implicit approach is a relaxation of the timestep constraints present in explicit approaches.
This is particularly important when considering the very fine grid spacing often required by the dynamic grid which, combined with the large bulk velocities occurring in flares, can lead to extremely oppressive timestep constraints.
\added{
Thermal conduction (which is typically stiff in an explicit treatment) is also computed as part of this system, using the flux limiter of \citet{Campbell1984}.
Whilst this limiter will limit the local electron flux to below the free-streaming limit, the implementation is not physically accurate and non-local transport terms resulting from the solution of the Vlasov-Fokker-Planck equation may further affect this term, however any adjustment of the thermal conduction treatment is outside the scope of the work presented here.
}

Despite its elegance, there are several major downsides to this implicit approach.
Foremost of these is the complexity engendered by the coupled design of the system, and the need to ensure that all necessary derivatives are analytically derived and correctly computed.
This presents a very large barrier to entry for future developments on the platform, and is likely part of the reason why both Fokker-Planck modules integrated in \Radyn{} have operated externally to this core coupled system.
Additionally, implicit codes, whilst having less severe timestep constraints, are typically much more costly per timestep than explicit codes.
This is somewhat offset by the majority of the cost of each step residing within the formal solver, which remains similar in both cases.
The dynamic grid can also become problematic due \replaced{the difficulty interpreting and manipulating the locations of the grid points}{a lack of interpretability and ability to manipulate how the points are spread}.
\added{The positions of these points are determined by a metric taking into account local variations and concentrations of multiple quantities, with manually determined weightings}.
These difficulties are linked to a tendency to drop to extremely fine spacings in shock regions, severely limiting the possible timestep (sub-micron spacings have been observed in non-convergent simulations).
Due to the fixed number of grid points used throughout the model, this reduces spatial accuracy elsewhere in the simulation.
The grid weights can be manually adjusted during a run \citep[e.g.][]{Kowalski2015}, but a reliable, fully automated process is much more desirable.

\Radyn{} is a fantastic tool that has enabled insight into many different flare-associated phenomena, and these comments merely intend to highlight avenues for future development within the field of RHD.
As the different applications of \Radyn{} continue to evolve in complexity, with projects such as multi-strand arcade and minority species modelling \citep[e.g.][]{Kerr2019,Polito2019,Kerr2020}, the code at the core of \Radyn{} will need to be modified by different researchers, and work facilitating this and highlighting additional factors to be considered in RHD modelling is key to the future development of this field.

As discussed previously with respect to \Lw{} and radiative transfer, a flexible framework designed for solving a class of problem can yield significant advances in productivity.
The task of designing, constructing, and testing a framework for a problem as complex as the complete quasi-one-dimensional RHD simulation of flares is too significant to be undertaken here.
Nevertheless, it may prove a powerful future development once the necessary specifications are defined.
In the following we focus on reprocessing aspects of the radiative transfer of previously computed \Radyn{} simulations and investigating important directions for future developments in RHD modelling of flares.

\section{Minority Species Modelling}

For flares, \Radyn{}'s primary focus is on the major spectral lines and continua of hydrogen, helium, and calcium.
These typically represent the bulk of the radiative energy lost from the chromosphere.
Singly ionised magnesium has also been shown to be an important contributor to these energy losses, however the h and k lines require a treatment including PRD to avoid significantly overestimating their losses.
The \Caii{} H and K lines are also somewhat affected by PRD, in addition to the hydrogen Lyman lines.
For the Lyman lines we will discuss strategies for approximating this treatment.
For \Caii{} H and K, it has been suggested that considering the radiative losses of these lines in CRD approximately accounts for the lack of detailed Mg\,\textsc{ii} h and k treatment if all of these transitions were treated with PRD \citep{Carlsson2002, Kerr2019a}.

Whilst the lines of these four species\added{, H, He, Mg, and Ca} are some of the strongest in the solar spectrum, and their continua mediate much of the energy leaving the chromosphere, there are other chromospheric transitions that can be used to diagnose the atmosphere.
An element treated as a ``minority species'' is assumed to not interact significantly with the energy balance of the simulation (i.e. the thermodynamic response of the model does not change significantly if this species is subject to a complete radiative treatment).
This should be true for most species with trace populations.
For example, optically thick Si\,\textsc{iv} formation in a heated chromosphere has been investigated in a minority species context by \citet{Kerr2019c}.
The radiative transfer calculations associated with a minority species can then be performed in a ``second-pass'' over a previously computed \Radyn{} simulation.
The MS\_RADYN code is a modification of \Radyn{} designed for this task; it takes the thermodynamic parameters from every timestep of a \Radyn{} simulation, along with the non-equilibrium hydrogen populations, and solves the kinetic equilibrium equation at each timestep for a minority species.
Due to the lack of atmospheric thermodynamic response to changes in the radiative output of this species, far more complex atomic models can be used, such as the 30 level model silicon atom used by \citet{Kerr2019c}.

An approach similar to that of minority species modelling can be applied to testing the methods used in \Radyn{}, the importance of certain omissions, and the feasibility of extensions.
Due to the reduced complexity of solving the kinetic equilibrium equations rather than the entire RHD system, these calculations typically run significantly faster than the original simulation.
In the following we will discuss the creation of a minority species tool for reprocessing \Radyn{} simulations, built on the \Lw{} framework, as well as its application to investigating the importance of overlapping transitions, and discuss the difficulties of including PRD in these simulations.
Building such a tool on the \Lw{} framework should provide researchers with a modern, simpler codebase that is easier to conceptualise and modify, allowing for investigation of effects to be included in \Radyn{} or future RHD codes.
Excluding the model atom definitions, the source code of the simulations presented in this chapter totals $\sim$1000 lines of Python, mostly following modern best practices.

This approach could also be applied to a simple investigation of the effects of a magnetic field on the outgoing radiation, by imposing an \emph{ad hoc} magnetic field (constant or varying) on the model atmosphere and computing the emergent line profiles, in a much simpler way than modifying \Radyn{} for this task.

\section{Reprocessing \Radyn{} Simulations with the \Lw{} Framework}

To perform a minority species simulation, a particular file from the original simulation, \texttt{atmost.dat}, must be provided.
From investigating the contents of this file we can determine the exact configuration of \Lw{} and the equations to be solved.
When requested, this file is written to for every internal timestep of the \Radyn{} simulation, and represents a limited subset of the less frequently written ``complete'' output (typically stored every \SI{0.1}{\second}).
It contains some metadata describing the size of the simulation, then for each internal timestep, it records the current timestep, the elapsed time, the current locations of the dynamic grid, the mass density profile, the electron density profile, the temperature structure, the vertical velocity, and the current hydrogen level populations.

For the validation of \Lw{} and this style of simulation, we also wish to compute and compare the hydrogen populations to those computed in \Radyn{}.
Several difficulties arise due to the non-thermal collisional rates used in the kinetic equilibrium calculation for hydrogen and helium.
The non-thermal collisional rates of \citet{1993Fang} are used to determine hydrogen ionisation, and require the beam energy deposition throughout the atmosphere at each timestep.
For helium, if the Fokker-Planck electron beam description is used, then the rates of \citet{Arnaud1985} are used, but these require integration over the electron energy distribution.
Whilst it is possible to add both of these to the \texttt{atmost.dat} file, the complete electron distribution information is very large, and we instead elect to use ``Emslie'' beam electron formalism \citep{Emslie1978}, for which the energy deposition profile throughout the atmosphere is sufficient to describe the non-thermal rates.
We therefore chose to slightly modify one of \Radyn{}'s output routines, and add the beam deposition profile to the \texttt{atmost.dat} file.
Our function for reading these files can handle files written both with and without this modification.
In the event that this beam heating information is not saved, an approximation of it can be reconstructed via interpolation from the information in \Radyn{}'s complete save file.
Our testing of this show that the approximation is relatively good, but short term, or particularly narrow heating features may be lost.
For this reason, all simulations presented here use the version with the beam energy deposition data.

With the above data we have sufficient information to construct the \Radyn{} thermodynamic atmosphere at any of its internal timesteps.
\added{
\Lw{} is then responsible for the determining the radiation field and atomic level populations throughout the atmosphere using the thermodynamic properties at each timestep loaded from the \Radyn{} output and the populations at the previous timestep.
Thus, the atomic level populations are computed in statistical equilibrium for the \Radyn{} starting atmosphere and are then evolved only by our simulation code using \Lw{}, and not \Radyn{}, which simply provides the thermodynamic structure of the atmosphere at each timestep.
}
\Lw{} does not make use of the mass density stored by \Radyn{} directly, but instead maps it to hydrogen density.
For this we use the default abundances in \Lw{}, based on \citet{Asplund2009}.
These differ to those used in \Radyn{}, but not significantly for any of the species discussed here.

Ignoring the advection term it is then simple to produce a minority species tool using this approach.
In many situations, the advection term has a small effect, and can safely be ignored \citep{Kasparova2003,Nejezchleba1998}.
The method for advancing the atomic populations in time employed in \Radyn{} is formulated on the dynamic grid, and this is not the case in \Lw{}, which assumes that the grid is static (although this limitation can be worked around).
We can simply use a fixed denser spatial sampling of the atmosphere to account for the motion of features such as the transition region over the course of the simulation.
This model then interpolates the thermodynamic properties and NLTE hydrogen populations for the starting atmosphere onto our stratification and computes the statistical equilibrium solution for the minority species in question.
For each subsequent timestep these properties are interpolated from the new \Radyn{} grid to the static grid, and the minority species populations can be advanced in time using the process described in Sec.~\ref{Sec:TimeDepPopUpdates}.

To reduce the number of grid points needed for a static stratification one could instead use a fixed column mass stratification.
The transition region moves very little in terms of column mass during the simulation, however it then becomes necessary to interpolate the populations from one column mass stratification to the next; a process which can introduce significant error if not undertaken with care.
This error can be reduced by renormalising each species' total number density throughout the atmosphere from the mass density and abundances, and this helps to avoid errors growing around regions of high gradient, such as the transition region.

All of these approaches were trialled with different \Radyn{} simulations, and it was clear that while the general evolution of the radiative output was similar, differences remained in the synthesised line profiles, especially those of \Caii{}.
To solve the minority species problem properly in a manner fully compatible with \Radyn{} it is necessary to include the advection terms, and so an advection treatment was added.
In the following we will describe two different approaches to handling the advective terms, drawing on our previous discussions of hydrodynamics, and thus solving the complete system of kinetic equilibrium equations.

\subsection{Advection}\label{Sec:MsLwAdvection}

In Sec.~\ref{Sec:RadynDissection} we discussed the coupled manner in which \Radyn{} solves the RHD equations.
For flexibility we wish to decouple the advection terms from the radiative effects.
Our initial approach was to use an explicit method on the dense, fixed grid discussed above.
This method draws the simple explicit finite-volume approaches discussed in Chap.~\ref{Chap:FlareModelling}, and thus uses a fifth-order WENO-NM scheme for reconstruction and the simple local Lax-Friedrichs flux for estimating the flow of the atomic populations through the simulation.
This numerical scheme performs extremely well in textbook advection and hydrodynamic tests, however it was found to be ill-suited to the long internal timesteps that \Radyn{}'s implicit method chooses.
These timesteps are longer than those permitted by the CFL condition, requiring the explicit method to perform multiple substeps for each of \Radyn{}'s timesteps.
This alone can introduce cumulative error, and is further compounded by the use of the dense static grid.
As this grid needs to conform to the requirements of the simulation over its entire evolution, rather than just its instantaneous requirements (as is the case for \Radyn{}'s grid) there are often dense clusters of points in regions where they are not currently required to resolve the atmospheric structure.
These regions may have high plasma flow velocities, further increasing the timestep restrictions on the explicit method.
In some cases several thousand applications of the explicit scheme were required to match one of \Radyn{}'s internal timesteps.
With such different timestep restrictions imposed on the two components of this simulation, it is difficult to correctly treat both processes in a coupled fashion.

Using this explicit approach for advection, a fair agreement with \Radyn{} was found, but performance was dramatically worsened.
A significant proportion of runtime had to be spent on the advective terms as the energy deposition in simulations increased, which increased the flow speeds and moved the transition region further from its starting altitude.
Due to \Radyn{}'s longer timesteps, during more explosive evaporative phases, our advection scheme was occasionally able to carry chromospheric material through the majority of the transition region.
Whilst the populations quickly evolved in their new environment this process is sufficiently slow to introduce unexpected variability in the line profiles.
A higher order splitting scheme might have helped to mitigate this but would add further computational cost to an already expensive process (due to the sheer number of advection steps needed).
This effect can also be mitigated by limiting the maximum timestep that can be taken by \Radyn{} during the creation of the baseline simulation.
However, limiting \Radyn{}'s performance is a poor solution to this problem; the explicit advection method described here could serve well at the core of a code designed around it, in the way that FLARIX and HYDRAD both use similar explicit advection schemes, but many difficulties are created by the difference in ideologies between this and \Radyn{}'s implicit dynamic grid.

To improve the agreement with \Radyn{}, reduce the number of interpolations, and leverage rather than fight its adaptive grid we instead decided to apply its technique for advection, but keep it distinct from the radiative transfer.
Thus, at the start of each timestep we advect the populations from the previous grid to the new grid locations, and then advance the populations in time based on the NLTE rates.
This method employs a variant of the second order spatially accurate method of \citet{VanLeer1979} to reconstruct the values on either side of the interface, of which the upwind value is chosen.
This is set within a time-centering scheme similar to that described by \citet{Dorfi1997}.
Under this scheme the advection stencil depends on the values of five cells, two on either side of the current one.
Thus the Jacobian matrix for this equation is pentadiagonal (and block pentadiagonal for the complete system of ODEs).
For simplicity and ease of implementation we chose to not directly code the expressions for these derivatives that occur in the Jacobian matrix, but instead compute them by finite differences.
There is an elegant technique that can be used to optimise this process when an equation's region of dependence is known.
This approach is known as Coloured Finite Difference \citep{Curtis1974}; so long as only one point in the domain affecting each output point is perturbed the gradient can be trivially attributed to the correct point.
In essence, we need only perform five additional evaluations of the advection residual, perturbing one point in every five, to fill the Jacobian, rather than the traditional approach where each point would be perturbed in turn.
The solution to this system is then computed by a Newton-Raphson iteration with Armijo line search \citep{Armijo1966} to accelerate convergence.

This technique has proven far more suited for reprocessing these simulations than the previous explicit scheme.
Only one application of the method (typically requiring at most five Newton-Raphson iterations) is needed for each timestep and the computational cost is typically $<0.1\,\%$ of the total CPU time.
This approach remains harder to debug and modify due to its implicit nature, although this is simplified thanks to the finite difference method for computing the Jacobian which does not need to be adjusted if the equations are modified, so long as the stencil remains the same.

The agreement in the synthesised lines was improved by the implementation of advection in our simulations, but substantial differences still remained in the spectral lines of \Caii{}.
In the following, we investigate the effects of different radiative treatments, and discuss possible implications on RHD modelling.

This final code used in these investigations is available on GitHub\footnote{\url{https://github.com/Goobley/MsLightweaver}} with archival on Zenodo \citep{MsLwThesisRelease}.
The code for the previous advection method on the dense fixed grid is available on the \texttt{Advection} branch of the same repository.
This is an early development branch of the code, as this method was not retained.


\section{Case Study: \Caii{} Photoionisation by the Hydrogen Lyman Lines}\label{Sec:CaiiPhotoionisation}

\emph{The content of this section is based on the work presented in \citet{Osborne2021a}.}

The methods discussed above can be used to reprocess the radiative transfer aspects of \Radyn{} simulations and thus investigate the effects of the Lyman lines on \Caii{} photoionisation in these models, as this was theorised to be the origin of possible differences in the \Caii{} line profiles.
In \Radyn{}, the photoionisation of \Caii{} by the hydrogen Lyman continuum is considered, but the effects of the Lyman lines are not.
The hydrogen Lyman lines are strongly enhanced in flares, and a two dex enhancement relative to quiet sun intensity was found by \citet{RubioDaCosta2009} using observations from the Transition Region and Coronal Explorer (TRACE).
RHD modelling using \Radyn{} has also suggested that enhancements at least this large are to be expected in this line \citep{Brown2018, Hong2019}.
Fig.~\ref{Fig:CaIIOverlaps} shows the overlap between the hydrogen Lyman transitions and the \Caii{} continua present in our model.
Radiation from Ly$\alpha$ photoionises \Caii{} from all levels other than the ground state.
All of the other Lyman transitions present can photoionise \Caii{} to \Caiii{} from all levels present in this model.
Additionally, in flaring conditions, the higher lines of the Lyman sequence are significantly Stark broadened and create a quasi-continuum between Ly$\delta$ and the Lyman continuum \citep{DeFeiter1975}, which will further enhance the photoionisation of \Caii{} from what is considered in our model.
These highly enhanced transitions therefore provide an important mechanism for the photoionisation of \Caii{} to \Caiii{} and in the following we will investigate the effect this has on both the emergent line profiles and the radiative losses of several RHD models.
These effects have long been considered in prominence modelling, starting with the work of \citet{Ishizawa1971}, however we are not aware of any previous detailed investigation of these effects in RHD modelling of flares, where the Lyman transitions become so significantly enhanced.

%spell-checker: disable
\begin{pycode}[TimeDepRT]
from MsLightweaverAtoms import H_6, CaII
from matplotlib.patches import Rectangle
from weno4 import weno4

# plt.ion()
H = H_6()
Ca = CaII()
fig = plt.figure(figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.55))
ax = plt.gca()

# C1 = '#EECC66'
# C2 = '#6699CC'
C1 = 'C1'
C2 = 'C0'

lineLabels = [r'Ly$\alpha$', r'Ly$\beta$', r'Ly$\gamma$', r'Ly$\delta$']
lineIdx = 0
for l in H.lines:
    if l.i != 0:
        continue
    plt.axvline(l.lambda0, c=C1)
    ha = 'center' if lineIdx != 2 else 'left'
    ax.annotate(lineLabels[lineIdx], xy=(l.lambda0, 1), xytext=(-1, 6),
                xycoords=ax.get_xaxis_transform(), textcoords='offset points', ha=ha, fontsize='small')
    lineIdx += 1

caLabels = [
    r'Ca\textsc{ii} 3p$^6$ 4s – Ca\textsc{iii}',
    r'Ca\textsc{ii} 3p$^6$ 4p – Ca\textsc{iii}',
    r'Ca\textsc{ii} 3p$^6$ 3d – Ca\textsc{iii}']
labelIdx = 0
for i, c in enumerate(Ca.continua[::2]):
    patch = Rectangle((c.minLambda, i-0.25), c.lambdaEdge - c.minLambda, 0.5, fc=C2, alpha=0.7)
    ax.add_patch(patch)
    ax.annotate(caLabels[labelIdx], xy=(c.lambdaEdge + 1, i), va='center', fontsize='small')
    labelIdx += 1
plt.ylim(-0.25, len(Ca.continua[::2])-0.75)
plt.xlim(80, 160)

c = H.continua[0]
patch = Rectangle((c.minLambda, -0.25), c.lambdaEdge - c.minLambda, 5, fc=C1,
                  alpha=0.5, hatch='/', ec=C1, lw=0.0)
ax.add_patch(patch)
plt.axvline(c.lambdaEdge, c=C1, ls='--', alpha=0.8)
ax.annotate('← LyC', xy=(c.lambdaEdge, 1), xytext=(-5, 6),
            xycoords=ax.get_xaxis_transform(), textcoords='offset points', ha='center', fontsize='small')

# yticks = np.arange(5)
# plt.yticks(yticks, ['A', 'B', 'C', 'D', 'E'])
plt.yticks([],[])

plt.xlabel(r"$\lambda$ [nm]")
# plt.tight_layout()
plt.subplots_adjust(left=0.02, right=0.98)
lFig = chRT.save_figure('CaIIOverlaps', fig, fext='.pgf')
lFig.caption = r'The overlap betwen the hydrogen Lyman lines and continuum with the Ca\,\textsc{ii} continua present in the model atom used here. Both the Ca\,\textsc{ii} 3p$^6$ 4p and 3p$^6$ 3d levels contain two sub-levels with indistinguishably different continuum edges.'
lFig.short_caption = r'Overlap between Lyman transitions and \Caii{} continua in model atoms used.'
lFig.placement = 'hbtp'
\end{pycode}

\py[TimeDepRT]|chRT.get_figure('CaIIOverlaps')|
%spell-checker: enable

The hydrogen (five bound levels with H\,\textsc{ii} continuum and ten lines), helium, and calcium (five bound \Caii{} levels with \Caiii{} continuum and five lines) model atoms used in the simulations presented here are the same as those used in \Radyn{}.
All other model atoms used in the LTE background opacities are taken from the \Lw{} standard library (and have in turn been converted from  RH distribution \citep{Uitenbroek2001}).
Currently only the hydrogen and calcium populations are fully treated in NLTE.
In the \Radyn{} models the tabulated LTE background emissivities and opacities of \citet{Gustafsson1973} are used.

To determine the importance of the photoionisation by the Lyman lines, each \Radyn{} simulation is reprocessed twice, once including the effects of the Lyman lines on \Caii{} (henceforth Lyman inclusive (LI)), and once without these effects (Lyman exclusive (LE)).
This is achieved through the use of two different hydrogen model atoms, where the one for the LE treatment excludes the Lyman lines and uses fixed hydrogen populations from \Radyn{}.
In both cases the effects of the Lyman continuum are included, as this is commonly considered in RHD codes, and allows for direct comparison of the LE simulation against \Radyn{}.
The simulations are performed using the CRD formalism for consistency with \Radyn{}, although the models used for the Lyman lines contain an approximation to PRD by removing radiative broadening and reducing van der Waals broadening.
This makes the line profile closer to a Doppler profile, by reducing the importance of the Lorentzian wings.
This is one of the two more common approaches to approximating PRD effects in these transitions, the other being to truncate the line quadrature around ten Doppler widths from the line core.
Both of these are empirical but we favour the former in flare simulations as the narrow grid used in the latter can easily ``lose'' opacity in the moderate to high Doppler shifts that occur in flare models (M. Carlsson 2021, \emph{private communication}).
PRD effects are also present in the \Caii{} lines --- primarily the resonance lines, although cross-redistribution effects also affect the infra-red triplet.
The effects on these are typically less significant than those on the hydrogen Lyman lines, especially due to the high chromospheric densities that occur during flares.
We therefore do not add any approximate PRD treatments to the \Caii{} lines.
These model atoms are identical between \Radyn{} and \Lw{}, and the two tools differ only in their description of LTE background opacities, which in the case of the \Lw{} simulations includes helium.
Comparison of these simulations should therefore enable the study of these photoionisation effects.

Our \Lw{}-based tool uses the first-order splitting technique discussed in Sec.~\ref{Sec:HydroStability} to temporally couple the two subproblems of the kinetic equilibrium equations.
The complete kinetic equilibrium equations are split into radiative and advective operators that are applied sequentially.
A Strang-splitting approach was trialled but provided no noticeable difference in the solution over this first-order technique, whilst being more computationally costly than the simpler approach.
After solving the statistical equilibrium problem to determine an initial solution for the atomic populations in the given starting atmosphere, the populations are then advected, and the thermodynamic atmospheric parameters are updated using the \Radyn{} data from the next timestep.
This update process includes the calculation of the LTE populations of all species considered and computing the resultant background opacities.
The atomic level populations are then advanced in time using the implicit approach described in Sec.~\ref{Sec:TimeDepPopUpdates}.
In the LI case, the simulations are performed with charge conservation as described in Sec.~\ref{Sec:ChargeCons}, and the electron density is advected with the atomic populations.
No difference in the radiative output was found between our charge conservation implementation, and that found by using the \Radyn{} values at each step, showing that this method is self-consistent.
The results of this were shown during \Lw{} validation in Fig.~\ref{Fig:LwValidationTimeDepNe} of Sec.~\ref{Sec:LwValidation}.

\subsection{The \Radyn{} simulations}\label{Sec:CaiiRadynSims}

For this investigation two \Radyn{} simulations were used.
Their parameters were chosen to serve as typical simulations, and were based on those used by \citet{Kerr2019, Kerr2019a}.
The same starting atmosphere derived from VAL3C \citep{Vernazza1981} as used in the F-CHROMA grid of simulations\footnote{\url{https://star.pst.qub.ac.uk/wiki/public/solarmodels/start.html}} was used.
As previously discussed, the ``Emslie'' beam formalism was chosen over the Fokker-Planck for ease of reconstructing any non-thermal rates that might be needed.
The spectral index\footnote{\added{The distribution of electrons with energy $E$ in a power-law distribution is proportional to $E^{-\delta}$ and is controlled by the spectral index $\delta$.}} used for the power-law distribution of electron energies was $\delta=5$, with a low-energy cut-off of \SI{20}{\kilo\electronvolt}.
The two simulations differed only in energy deposition, which was a constant flux for \SI{10}{\second} of $1\times{}10^{6}$ or $1\times{}10^{7}\,\si{\joule\per\square\metre\per\second}$ \footnote{In the cgs units that are commonly adopted for \Radyn{} simulations these represent $1\times{}10^9$ and $1\times{}10^{10}\,\si{\erg\per\square\centi\metre\per\second}$.}
These simulations will be referred to as F9 and F10 respectively.

All of these parameters fall within the range of those used in the F-CHROMA grid, other than the beam energy flux which is lower than the peak fluxes used in the grid.
This is primarily due to the triangular \SI{20}{\second} duration heating profile used in the grid, which is less demanding on the simulation than the constant deposition used in our simulations.

Our choice of parameters are also supported by observational data.
The low-energy cut-off is in accord with the findings of \citet{Sui2007} whose analysis of 33 early impulsive flares using the Ramaty High Energy Solar Spectroscopy Imager (RHESSI) found a range of 10-\SI{50}{\kilo\electronvolt} whilst accounting for X-ray albedo and under the assumption of a cold collisional thick target model.
Another study of 53 flares using RHESSI by \citet{Saint-Hilaire2008} found that the photon spectral index $\gamma$ was distributed between 2 and 5, peaking between 3 and 3.5.
Given this, our choice of spectral index is reasonable and lies well inside this distribution as the spectral index of the electron beam is related to the photon spectral index by $\delta = \gamma + 1$.

For both of these simulations \Radyn{}'s additional coronal \added{X-ray and extreme ultraviolet (XEUV)} irradiation terms were disabled due to discrepancies that were found between \replaced{these and their re-implementation in}{ the implementation of these in \Radyn{} and} \Lw{}.
\added{Thus, no coronal XEUV irradiation terms were used in either \Radyn{} or \Lw{}, as this was necessary to ensure agreement in the LE case, allowing the differences in the LI case to be assessed.}
Additionally, the maximum timestep allowed in \Radyn{} was limited to \SI{0.01}{\second}.
This was primarily due to experiments with the explicit advection scheme, but likely also reduced the possible loss of accuracy due to the operator splitting scheme used in our final reprocessed simulations.

\subsection{Line Profiles}\label{Sec:TimeDep8542Profiles}

%spell-checker: disable
\begin{pycode}[TimeDepRT]
import zarr
from matplotlib.ticker import MultipleLocator, AutoMinorLocator
from MsLightweaverAtoms import CaII
import astropy.units as u
import lightweaver as lw
from radynpy.cdf import LazyRadynData

# Get the RADYN intensity for a line down a particular direction; in SI
def line_intensity_with_cont(data, kr, muIdx):
    if not not data.cont[kr]:
        # print('line_intensity cannot compute bf intensity')
        # return
        raise ValueError('line_intensity cannot compute bf intensity')

    wl = data.alamb[kr] / (data.q[0:data.nq[kr], kr] *  data.qnorm * 1e5 / data.cc + 1)
    intens = (data.outint[:, 1:data.nq[kr]+1, muIdx, kr] + data.outint[:, 0, muIdx, kr][:, np.newaxis]) *  data.cc * 1e8 / (wl**2)[np.newaxis, :]
    # print(intens.shape)
    # wl is retruned in angstrom, intens in erg/cm^2/sr/A/s
    wl = wl[::-1] << u.Angstrom
    intens = lw.utils.convert_specific_intensity(wl, intens[:, ::-1] << u.erg / u.cm**2 / u.sr / u.Angstrom / u.s, 'J/m2/sr/Hz/s')

    return wl << u.nm, intens

def plot_8542_profiles(liData, leData, radyn):
    plotTimes = [5, 11, 20, 40]
    fig, ax = plt.subplots(1, 4, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.40),
                           sharex=True, sharey=True,
                           gridspec_kw={'wspace': 0.1, 'width_ratios':[1,1,1,1]})
    fig.subplots_adjust(left=0.12, right=0.99)
    ax = ax.ravel()

    lineData = line_intensity_with_cont(radyn, 20, -1)
    waveRange = (854.3444, 854.5444)
    ca = CaII()
    wavelength = liData['wavelength'][...]
    wavelengthLE = leData['wavelength'][...]
    for i, time in enumerate(plotTimes):
        lwIdx = np.searchsorted(liData['time'], time)
        radynIdx = np.searchsorted(radyn.time, time)
        lambda0 = ca.lines[-1].lambda0

        if i == 0:
            ax[i].plot(lineData[0].value - lambda0, lineData[1][radynIdx], label='RADYN')
            ax[i].plot(wavelength - lambda0, liData['Iwave'][lwIdx, :, -1], '--', label='Lightweaver LI')
            ax[i].plot(wavelengthLE - lambda0, leData['Iwave'][lwIdx, :, -1], '--', label='Lightweaver LE')
        else:
            ax[i].plot(lineData[0].value - lambda0, lineData[1][radynIdx])
            ax[i].plot(wavelength - lambda0, liData['Iwave'][lwIdx, :, -1], '--')
            ax[i].plot(wavelengthLE - lambda0, leData['Iwave'][lwIdx, :, -1], '--')

        ax[i].set_title('{:.2f} s'.format(time))
        ax[i].xaxis.set_minor_locator(AutoMinorLocator())

    ax[0].set_yscale('log')
    ax[0].set_ylim(1e-8, 1.3e-7)
    ax[0].set_xlim(-0.08, 0.08)

    ax[0].yaxis.offsetText.set_visible(False)
    ax[0].set_ylabel('Specific Intensity [SI]')
    for a in ax:
        a.set_xlabel('$\Delta\lambda$ [nm]')
    fig.subplots_adjust(bottom=0.15)
    fig.legend(*ax[0].get_legend_handles_labels(), loc=(0.79,0.64), frameon=False,
               handletextpad=0.42, handlelength=1.45, fontsize=9)#, bbox_to_anchor=(0.5,0.53))
#     fig.savefig('LineProfiles1e10_8542.png', dpi=300)
    return fig

from radynpy.cdf import LazyRadynData
radyn = LazyRadynData(chRT.data_file('Flat1e9NoIncRad/radyn_out.cdf'))
liData = zarr.convenience.open(chRT.data_file('Flat1e9NoIncRad/Flat1e9NoIncRadLIThesis.zip'), 'r')
leData = zarr.convenience.open(chRT.data_file('Flat1e9NoIncRad/Flat1e9NoIncRadLEThesis.zip'), 'r')
fig = plot_8542_profiles(liData, leData, radyn)
lFig = chRT.save_figure('F9Profiles', fig, fext='.pgf')
lFig.caption = r'Comparison of the LI, LE, and RADYN Ca\,\textsc{ii} \SI{854.2}{\nano\metre} line profiles during the F9 simulation.'
lFig.short_caption = r'Comparison of \CaLine{} treatments in the F9 simulation.'

radynF10 = LazyRadynData(chRT.data_file('Flat1e10NoIncRad/radyn_out.cdf'))
liDataF10 = zarr.convenience.open(chRT.data_file('Flat1e10NoIncRad/Flat1e10NoIncRadLIThesis.zip'), 'r')
leDataF10 = zarr.convenience.open(chRT.data_file('Flat1e10NoIncRad/Flat1e10NoIncRadLEThesis.zip'), 'r')
fig = plot_8542_profiles(liDataF10, leDataF10, radynF10)
lFig = chRT.save_figure('F10Profiles', fig, fext='.pgf')
lFig.caption = r'Comparison of the LI, LE, and RADYN Ca\,\textsc{ii} \SI{854.2}{\nano\metre} line profiles during the F10 simulation.'
lFig.short_caption = r'Comparison of \CaLine{} treatments in the F10 simulation.'
\end{pycode}
\py[TimeDepRT]|chRT.get_figure('F9Profiles')|
\py[TimeDepRT]|chRT.get_figure('F10Profiles')|
%spell-checker: enable

The \CaLine{} line profile from 5, 11, 20, and \SI{40}{\second} after the onset of heating in the F9 and F10 simulations is shown in Figs.~\ref{Fig:F9Profiles} and \ref{Fig:F10Profiles} respectively.
These figures show the comparison of the LI and LE treatments, as well as the reference line profiles computed by \Radyn{}.
Despite the different formal solvers and numerical techniques, the agreement between the \Radyn{} and LE profiles is extremely good, differing by a few per cent at most.
There are substantial differences between the LI and LE models: in the F9 simulation the LI line profile is narrower, consistently double-peaked, and less intense than the LE profile, which is much more variable, including becoming singly-peaked after the heating ends ($t=11$ and \SI{20}{\second}), before returning to a double-peaked shape at later times in the simulation.

The differences in the outgoing radiation in the F10 case (Fig.~\ref{Fig:F10Profiles}) are still significant, but perhaps a little less dramatic than the F9 case.
The LI peak intensity is significantly reduced relative to the LE line profile in the $t=\SI{5}{\second}$ plot, and post-heating ($t=\SI{11}{\second}$) the asymmetry of the double-peaked profiles is reversed between the LI and LE treatments.
At $t=\SI{20}{\second}$ the situation is similar to the F9 simulation: the LE treatment produces a singly-peaked line profile, whilst the LI treatment produces an asymmetric double-peaked profile (due to the appearance of a secondary peak on the violet wing).
At later times there is a significant dip in the far violet wing for the LE treatment that is not present in the LI treatment.
This dip varies slowly in position and depth over the evolution of the cooling phase.

We can investigate the formation of these line profiles by looking at the contribution functions, and the atomic level populations associated with these spectral lines.
From Figs.~\ref{Fig:F9Profiles} and \ref{Fig:F10Profiles}, we consider that the difference between the two treatments is most significant at $t=11$ and \SI{20}{\second}.
The contribution functions and associated atomic level populations for these two times in both of the simulations are plotted in Figs.~\ref{Fig:F9ContFn11s}-\ref{Fig:F10ContFn20s}.



%spell-checker: disable
\begin{pycode}[TimeDepRT]
from ReadAtmost import read_atmost
from lightweaver.rh_atoms import H_6_atom, C_atom, O_atom, OI_ord_atom, Si_atom, Al_atom, Fe_atom, FeI_atom, MgII_atom, N_atom, Na_atom, S_atom, CaII_atom, He_9_atom
from MsLightweaverAtoms import H_6, CaII, H_6_nasa, CaII_nasa, H_6_nobb
from lightweaver.LwCompiled import FastBackground
from weno4 import weno4
from matplotlib.colors import LogNorm, SymLogNorm
from contextlib import redirect_stdout
import os

atmost = read_atmost(chRT.data_file('Flat1e9NoIncRad/atmost.dat'))
atmost.to_SI()
atmostF10 = read_atmost(chRT.data_file('Flat1e10NoIncRad/atmost.dat'))
atmostF10.to_SI()

# Set up atmosphere with data from initial timestep
nHTot = atmost.d1 / (lw.DefaultAtomicAbundance.massPerH * lw.Amu)
atmos = lw.Atmosphere.make_1d(scale=lw.ScaleType.Geometric, depthScale=np.copy(atmost.z1[0]),
                              temperature=np.copy(atmost.tg1[0]), vlos=np.copy(atmost.vz1[0]),
                              vturb=np.copy(atmost.vturb), ne=np.copy(atmost.ne1[0]), nHTot=np.copy(nHTot[0]))
atmos.quadrature(5)
FchromaAtoms = [H_6(), CaII(), He_9_atom(), C_atom(), O_atom(), Si_atom(), Fe_atom(),
                MgII_atom(), N_atom(), Na_atom(), S_atom()]

# Set up our atoms and Lightweaver context
aSet = lw.RadiativeSet(FchromaAtoms)
aSet.set_active('H', 'Ca')
spect = aSet.compute_wavelength_grid()
eqPops = aSet.compute_eq_pops(atmos)
def fast_background(*args, Nthreads=12):
    return FastBackground(*args, Nthreads=Nthreads)
ctx = lw.Context(atmos, spect, eqPops, initSol=lw.InitialSolution.Lte, conserveCharge=False, Nthreads=12, backgroundProvider=fast_background)
ctx.depthData.fill = True

# Add the extra information expected by our Atoms with Fang non-thermal beam collisional rates
atmos.bHeat = np.ones_like(atmost.bheat1[0]) * 1e-20
atmos.hPops = eqPops['H']

# An omission from Lightweaver (will be added in a later version), computes tau from the complete chi array
def compute_tau(ctx, mu):
    upDown = 1
    tau = np.zeros_like(ctx.depthData.chi[:, mu, upDown, :])
    chi = ctx.depthData.chi
    atmos = ctx.kwargs['atmos']

    # NOTE(cmo): Compute tau for all wavelengths
    tau[:, 0] = 1e-20
    for k in range(1, tau.shape[1]):
        tau[:, k] = tau[:, k-1] + 0.5 * (chi[:, mu, upDown, k] + chi[:, mu, upDown, k-1]) \
                                      * (atmos.height[k-1] - atmos.height[k]) / atmos.muz[mu]
    return tau

# Load the data from a particular timestep into the Lightweaver context
def load_timestep(atmost, file, idx):
    nHTot = atmost.d1 / (lw.DefaultAtomicAbundance.massPerH * lw.Amu)
    internalIdx = np.searchsorted(atmost.time, file['time'][idx])
    atmos.temperature[:] = atmost.tg1[internalIdx]
    atmos.vlos[:] = atmost.vz1[internalIdx]
    atmos.ne[:] = atmost.ne1[internalIdx]
    nHTot = atmost.d1[internalIdx] / (lw.DefaultAtomicAbundance.massPerH * lw.Amu)
    atmos.nHTot[:] = nHTot
    atmos.bHeat[:] = atmost.bheat1[internalIdx]

    atmos.height[:] = atmost.z1[internalIdx]

    for name, pops in file['eqPops'].items():
        if 'n' in pops.keys():
            eqPops.atomicPops[name].pops[:] = pops['n'][idx]
        eqPops.atomicPops[name].nStar[:] = pops['nStar'][idx]
    atmos.ne[:] = file['ne'][idx]
    ctx.update_deps()

# Support functions for plotting the contribution function
def scale_cfn(cfn, scaleLimits=None):
    cfnLog = cfn
    if scaleLimits is None:
        minVal = np.min(cfnLog[np.isfinite(cfnLog)])
        maxVal = np.max(cfnLog[np.isfinite(cfnLog)])
    else:
        minVal = scaleLimits[0]
        maxVal = scaleLimits[1]
    cfnLog = np.clip(cfnLog, minVal, maxVal)
    return cfnLog

# Scale a line profile to overlie the contfn
def scale_profile(wavelengthGrid, profile, wavelengthRange, scaleRange):
    minIdx = np.searchsorted(wavelengthGrid, wavelengthRange[0])
    maxIdx = np.searchsorted(wavelengthGrid, wavelengthRange[1]) + 1

    profile = np.copy(profile)
    profile -= profile[minIdx:maxIdx].min()
    profile /= profile[minIdx:maxIdx].max()
    profile *= (scaleRange[1] - scaleRange[0])
    profile += scaleRange[0]
    return profile

# Compute the tau=1 line via interpolation
def tau1_line(tau, z):
    tau1 = np.zeros(tau.shape[0])

    for la in range(tau.shape[0]):
        tau1[la] = weno4(1.0, tau[la], z)

    return tau1

def quiet_pls(fn, *args, **kwargs):
    with open(os.devnull, 'w') as devnull:
        with redirect_stdout(devnull):
            return fn(*args, **kwargs)

def plot_cfn(timeToPlot, liData, leData, atmost):
    lwIdx = np.searchsorted(liData['time'], timeToPlot)
    internalIdx = np.searchsorted(atmost.time, liData['time'][lwIdx])

    wavelength = liData['wavelength'][...]
    wavelengthLE = leData['wavelength'][...]
    # Use ctx for LI case
#     load_timestep('TimestepsAdvNrLosses/', lwIdx)
    def load_iter_ctx(data, idx):
        load_timestep(atmost, data, idx)
        for i in range(15):
            dJ = ctx.formal_sol_gamma_matrices()
            if dJ < 1e-3:
                break
    quiet_pls(load_iter_ctx, liData, lwIdx)

    fullNe = np.copy(ctx.kwargs['atmos'].ne)
    fullTau = compute_tau(ctx, mu=-1)
    fullCfn = lw.compute_contribution_fn(ctx, mu=-1)
    caPopsFull = np.copy(ctx.eqPops['Ca'])

    # LE case
    quiet_pls(load_iter_ctx, leData, lwIdx)

    noLybbNe = np.copy(ctx.kwargs['atmos'].ne)
    noLybbTau = compute_tau(ctx, mu=-1)
    noLybbCfn = lw.compute_contribution_fn(ctx, mu=-1)
    caPopsNoLybb = np.copy(ctx.eqPops['Ca'])

    # Now plot
    fig, ax = plt.subplots(1, 3, sharey=True, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.45),
    gridspec_kw={'wspace':0.1})
    fig.subplots_adjust(left=0.12, right=0.99)

    heightEdges = lw.compute_height_edges(ctx) / 1e6
    wlEdges = lw.compute_wavelength_edges(ctx)

    minVal = max(np.min(noLybbCfn), np.min(fullCfn))
    maxVal = max(np.max(noLybbCfn), np.max(fullCfn))

    fullCfnLog = scale_cfn(fullCfn, scaleLimits=None)
    noLybbCfnLog = scale_cfn(noLybbCfn, scaleLimits=None)
    ca = CaII()
    line = ca.lines[-1]
    lambda0 = line.lambda0
    waveRange = (-0.1, 0.1)
    waveRangeFull = (854.3444, 854.5444)
    lowerIdx = np.searchsorted(wlEdges-lambda0, waveRange[0]) - 1
    higherIdx = np.searchsorted(wlEdges-lambda0, waveRange[1]) + 1
    ax[0].pcolormesh(wlEdges[lowerIdx:higherIdx+1]-lambda0, heightEdges, fullCfn.T[:, lowerIdx:higherIdx], cmap='Blues', norm=SymLogNorm(linthresh=5e-14, vmin=1e-20, vmax=maxVal), rasterized=True)
    ax[1].pcolormesh(wlEdges[lowerIdx:higherIdx+1]-lambda0, heightEdges, noLybbCfn.T[:, lowerIdx:higherIdx], cmap='Blues', norm=SymLogNorm(linthresh=5e-14, vmin=1e-20, vmax=maxVal), rasterized=True)

    ax[0].set_xlim(*waveRange)
    ax[1].set_xlim(*waveRange)
    ax[0].set_ylim(None, 2.4)

    tau1LI = tau1_line(fullTau, atmost.z1[internalIdx] / 1e6)
    tau1LE = tau1_line(noLybbTau, atmost.z1[internalIdx] / 1e6)
    ax[0].plot(wavelength-lambda0, scale_profile(wavelength, liData['Iwave'][lwIdx, :, -1], waveRangeFull, ax[0].get_ylim()), alpha=0.5)
    ax[0].plot(wavelength-lambda0, tau1LI, 'r', alpha=0.5)
    ax[1].plot(wavelengthLE-lambda0, scale_profile(wavelengthLE, leData['Iwave'][lwIdx, :, -1], waveRangeFull, ax[0].get_ylim()), '--', alpha=0.5)
    ax[1].plot(wavelength-lambda0, tau1LE, 'r', alpha=0.5)

    ax[2].semilogx(caPopsFull[line.j], atmost.z1[internalIdx] / 1e6, c='C0', label='upper')
    ax[2].semilogx(caPopsFull[line.i], atmost.z1[internalIdx] / 1e6, c='C1', label='lower')
    ax[2].semilogx(caPopsNoLybb[line.j], atmost.z1[internalIdx] / 1e6, '--', c='C0')
    ax[2].semilogx(caPopsNoLybb[line.i], atmost.z1[internalIdx] / 1e6, '--', c='C1')
    ax[2].semilogx(caPopsFull[-1], atmost.z1[internalIdx] / 1e6, c='C3', label=r'Ca \textsc{iii}')
    ax[2].semilogx(caPopsNoLybb[-1], atmost.z1[internalIdx] / 1e6, '--', c='C3')
    ax[2].semilogx(caPopsNoLybb[-1][0], atmost.z1[internalIdx][0] / 1e6, 'C2', label='Temperature')

    ax[2].tick_params(axis='x', which='both')
    ax[0].set_xticks([-0.05, 0, 0.05])
    ax[0].xaxis.set_minor_locator(AutoMinorLocator())
    ax[1].set_xticks([-0.05, 0, 0.05])
    ax[1].xaxis.set_minor_locator(AutoMinorLocator())
    ax3 = ax[2].twiny()
    fig.subplots_adjust(top=0.82, bottom=0.18, hspace=0.5)
    ax3.semilogx(atmost.tg1[internalIdx], atmost.z1[internalIdx] / 1e6, c='C2')
    ax3.set_xlabel('T [K]', c='C2')
    ax[2].set_xlabel('Number Density [m$^{-3}$]')
    ax[0].set_xlabel('$\lambda$ [nm]')
    ax[1].set_xlabel('$\lambda$ [nm]')
    ax[0].set_ylabel('Height [Mm]')
    ax[0].set_title('Full treatment', size=11)
    ax[1].set_title('Lyman lines excluded', size=11)
    # for a in ax:
    #     a.tick_params(which='both', direction='in')
    # ax3.tick_params(which='both', direction='in')
    leg = fig.legend(*ax[2].get_legend_handles_labels(), loc=(0.75,0.23), frameon=False, handletextpad=0, handlelength=0)#, bbox_to_anchor=(0.5,0.53))
    legLines = leg.get_lines()
    for line in legLines:
        line.set_linestyle(' ')

    for handle, label in zip(leg.legendHandles, leg.texts):
        label.set_color(handle.get_color())
    fig.suptitle('Time: {:.2f} s'.format(atmost.time[internalIdx]))
    cfnData = {'LI': fullCfn.T[:, lowerIdx:higherIdx], 'LE': noLybbCfn.T[:, lowerIdx:higherIdx],
               'wavelengthEdges': wlEdges[lowerIdx:higherIdx+1]-lambda0, 'heightEdges': heightEdges, 'maxVal': maxVal, 'wavelengthTau1': wavelength - lambda0,
               'tau1LI': tau1LI, 'tau1LE': tau1LE}
    return fig, cfnData
    # fig.savefig('ContFn1e10_8542_%d.png' % atmost.time[lwIdx], dpi=300)

plotTimes = [11.0, 20.0]
F9Cfns = []
for timeToPlot in plotTimes:
    fig, cfnData = plot_cfn(timeToPlot, liData, leData, atmost)
    F9Cfns.append(cfnData)
    lFig = chRT.save_figure('F9ContFn{:.0f}s'.format(timeToPlot), fig, fext='.pgf', dpi=500)
    if timeToPlot == plotTimes[0]:
        lFig.caption = r'\CaLine{{}} contribution functions and level populations for the two calcium treatments in the F9 simulation at $t = \SI{{{:.0f}}}{{\second}}$. The two left-hand panels show the contribution function, overlaid with the line profile in blue and the $\tau_\nu=1$ line in red. The right-hand panel shows the structure of the atmosphere, with populations from the LI treatment shown with solid lines and the LE treatment with dashed lines.'.format(timeToPlot)
    else:
        lFig.caption = r'\CaLine{{}} contribution functions and level populations for the two calcium treatments in the F9 simulation at $t = \SI{{{:.0f}}}{{\second}}$. The panels present the same information as Fig.~\ref{{Fig:F9ContFn{:.0f}s}}.'.format(timeToPlot, plotTimes[0])
    lFig.short_caption = r'\CaLine{{}} contribution functions and level populations for the two calcium treatments in the F9 simulation at $t = \SI{{{:.0f}}}{{\second}}$.'.format(timeToPlot)
    lFig.placement = r'htbp'

F10Cfns = []
for timeToPlot in plotTimes:
    fig, cfnData = plot_cfn(timeToPlot, liDataF10, leDataF10, atmostF10)
    F10Cfns.append(cfnData)
    lFig = chRT.save_figure('F10ContFn{:.0f}s'.format(timeToPlot), fig, fext='.pgf', dpi=500)
    lFig.caption = r'\CaLine{{}} contribution functions and level populations for the two calcium treatments in the F10 simulation at $t = \SI{{{:.0f}}}{{\second}}$. The panels present the same information as Fig.~\ref{{Fig:F9ContFn{:.0f}s}}.'.format(timeToPlot, plotTimes[0])
    lFig.short_caption = r'\CaLine{{}} contribution functions and level populations for the two calcium treatments in the F10 simulation at $t = \SI{{{:.0f}}}{{\second}}$.'.format(timeToPlot)
    lFig.placement = r'htbp'
\end{pycode}

\py[TimeDepRT]|chRT.get_figure('F9ContFn11s')|
\py[TimeDepRT]|chRT.get_figure('F9ContFn20s')|
\py[TimeDepRT]|chRT.get_figure('F10ContFn11s')|
\py[TimeDepRT]|chRT.get_figure('F10ContFn20s')|
%spell-checker: enable

The level populations for both treatments are plotted in the right-hand panel of these figures.
The LI and LE treatments produce significantly different populations for the upper and lower levels of the \CaLine{} transition.
The left-hand and centre panels present the contribution functions for the two different treatments with the $\tau_\nu=1$ line overlaid in red.
The $\tau_\nu=1$ line is reliably extended to higher altitudes in the line core of the LE treatment, suggesting that this core is formed in a different location between the two treatments.
There is a significant feature contributing to the violet wing of the LE models around the \SI{1.5}{\mega\metre} region.
In this same region both the upper and lower level populations for the \CaLine{} transition are significantly enhanced over their LI values, creating an increase in opacity, whilst keeping the source function approximately constant, leading to the attenuation of radiation from deeper in the atmosphere.
Under the LI treatment we instead see that there is substantially more \Caiii{} in this region, likely due to \Caii{} to \Caiii{} photoionisation from Lyman lines formed in the upper chromosphere and transition region.
In the F10 simulation there is also a significant difference between the \Caiii{} populations computed in the two treatments around the temperature minimum region; this is much deeper than any of the \Caii{} spectral line cores typically form, but is likely due to the same photoionisation process and the effects of the much larger Lyman line intensity that occurs in the F10 model.

\added{
For both the F9 and F10 simulations, the effect of the Lyman lines on the calcium level populations (enhanced \Caiii{}, reduced \Caii{}) in the upper chromosphere is similar to that found by \citet{Gouttebroze2002} in prominence models, although the magnitude of the effect is larger here, likely due to the strong enhancement of the Lyman lines in these flare models.
}

\subsection{Radiative Losses}
%spell-checker: disable
\begin{pycode}[TimeDepRT]
import matplotlib.ticker as ticker
from weno4 import weno4
def plot_loss_comparison(liData, leData, radyn):
    # Get the losses from RADYN for the appropriate transitions
    radynCaIdxs = []
    radynHCaIdxs = []
    radynTotIdxs = []

    for kr in range(radyn.ielrad.shape[0]):
        if radyn.ielrad[kr] == 2 and radyn.cont[kr] == 0:
            radynCaIdxs.append(kr)
        if radyn.ielrad[kr] == 1 or radyn.cont[kr] == 0:
            radynTotIdxs.append(kr)
        if str(radyn.atomid[0, radyn.ielrad[kr]-1]).startswith('he') and radyn.cont[kr] == 1 and radyn.alamb[kr] < 900.0:
            radynTotIdxs.append(kr)
        if (radyn.ielrad[kr] == 1 or radyn.ielrad[kr] == 2) and radyn.cont[kr] == 0:
            radynHCaIdxs.append(kr)
        if (radyn.ielrad[kr] == 1) and radyn.cont[kr] == 1:
            radynHCaIdxs.append(kr)
        if str(radyn.atomid[0, radyn.ielrad[kr]-1]).startswith('he') and radyn.cont[kr] == 1 and radyn.alamb[kr] < 900.0:
            radynHCaIdxs.append(kr)

    radynCaLosses = np.sum(np.abs(radyn.cool[:,:,radynCaIdxs]), axis=-1)
    radynAbsCool = np.sum(np.abs(radyn.cool[:,:,radynTotIdxs]), axis=-1)

    fig = plt.figure(figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.45))
    fig.subplots_adjust(left=0.12, right=0.95, top=0.85, bottom=0.15)
    gs = fig.add_gridspec(1, 5, width_ratios=[1, 0.07, 0.18, 1, 0.07], height_ratios=[1])
#     gs.update(left=0.1, right=0.95, wspace=0.2, hspace=0.4)
    caLossesBig = []
    caLossesLEBig = []
    radynCaLossesBig = []
    radynAbsCoolBig = []
    tempInterp = []
    fixedZGrid = np.linspace(radyn.z1[0].min(), 2.5e8, 10000)
    # Get the losses for ~250 timesteps (0.2s cadence)
    for tIdx in range(liData['time'].shape[0]):
        rIdx = np.searchsorted(radyn.time, liData['time'][tIdx])
        tempInterp.append(weno4(fixedZGrid, radyn.z1[rIdx], radyn.tg1[rIdx]))
        caLosses = np.sum(np.abs(np.stack(liData['losses'][tIdx, -5:])), axis=0)
        caLossesLE = np.sum(np.abs(np.stack(leData['losses'][tIdx, -5:])), axis=0)
        caLossesBig.append(weno4(fixedZGrid, radyn.z1[rIdx], caLosses))
        caLossesLEBig.append(weno4(fixedZGrid, radyn.z1[rIdx], caLossesLE))
        radynCaLossesBig.append(weno4(fixedZGrid, radyn.z1[rIdx], radynCaLosses[rIdx]))
        radynAbsCoolBig.append(weno4(fixedZGrid, radyn.z1[rIdx], radynAbsCool[rIdx]))
    caLossesBig = np.stack(caLossesBig)
    caLossesLEBig = np.stack(caLossesLEBig)
    radynCaLossesBig = np.stack(radynCaLossesBig)
    radynAbsCoolBig = np.stack(radynAbsCoolBig)
    tempInterp = np.stack(tempInterp)

    zEdges = np.concatenate(((fixedZGrid[0] + 0.5 * (fixedZGrid[0] - fixedZGrid[1]),),
                    0.5 * (fixedZGrid[1:] + fixedZGrid[:-1]),
                    (fixedZGrid[-1] + 0.5 * (fixedZGrid[-1] - fixedZGrid[-2]),)
                   ))
    timeEdgesRadyn = np.concatenate(((0,), 0.5 * (radyn.time[:-1] + radyn.time[1:]), (radyn.time[-1],)))
    timeEdges = np.concatenate(((0,), 0.5 * (liData['time'][:-1] + liData['time'][1:]), (liData['time'][-1],)))

    ax0 = fig.add_subplot(gs[0])
    cb0 = fig.add_subplot(gs[1])
    ax1 = fig.add_subplot(gs[3])
    cb1 = fig.add_subplot(gs[4])
    lpanel = ((caLossesLEBig - caLossesBig) / (caLossesLEBig)).T
    rpanel = (radynCaLossesBig / radynAbsCoolBig).T
    maxVal = max(lpanel.max(), abs(lpanel.min()))
    mesh0 = ax0.pcolormesh(timeEdges, zEdges / 1e8,
                           lpanel
                           , cmap='RdBu_r', norm=SymLogNorm(linthresh=1e-2, vmax=maxVal, vmin=-maxVal),
                           rasterized=True)
    mesh1 = ax1.pcolormesh(timeEdges, zEdges / 1e8,
                           rpanel
                           , cmap='Spectral_r', vmax=0.4,
                           rasterized=True)
    fig.colorbar(mesh0, cax=cb0)
    fig.colorbar(mesh1, cax=cb1)
    ax0.set_title('Relative change of Ca line losses\nwith LE and LI treatments')
    ax1.set_title('Proportion of total radiative\nlosses due to Ca lines')
    ax0.set_xlabel('t [s]')
    ax1.set_xlabel('t [s]')
    ax0.set_ylabel('Height [Mm]')

    panelData = {'timeEdges': timeEdges, 'zEdges': zEdges / 1e8, 'data': lpanel * rpanel}

    return fig, panelData
    # fig.savefig('Losses1e10_Im.png', dpi=300)
    # with open('F10LossPanels.pickle', 'wb') as pkl:
    #     pickle.dump({'timeEdges': timeEdges, 'zEdges': zEdges / 1e8, 'data': lpanel * rpanel}, pkl)

fig, F9PanelData = plot_loss_comparison(liData, leData, radyn)
lFig = chRT.save_figure('F9LossComparison', fig, fext='.pgf', dpi=500)
lFig.caption = 'Time evolution of the calcium losses in the F9 simulation. The left-hand panel shows the absolute relative change in losses due to the different calcium treatments, and the right-hand panel shows the proportion of the total radiative losses due to the calcium lines.'
lFig.short_caption = 'Time evolution of the calcium losses in the F9 simulation.'

fig, F10PanelData = plot_loss_comparison(liDataF10, leDataF10, radynF10)
lFig = chRT.save_figure('F10LossComparison', fig, fext='.pgf', dpi=500)
lFig.caption = 'Time evolution of the calcium losses in the F10 simulation. The left-hand panel shows the absolute relative change in losses due to the different calcium treatments, and the right-hand panel shows the proportion of the total radiative losses due to the calcium lines.'
lFig.short_caption = 'Time evolution of the calcium losses in the F10 simulation.'
\end{pycode}
\py[TimeDepRT]|chRT.get_figure('F9LossComparison')|
\py[TimeDepRT]|chRT.get_figure('F10LossComparison')|
%spell-checker: enable

%spell-checker: disable
\begin{pycode}[TimeDepRT]
def plot_loss_variation(F9LossData, F10LossData):
    fig = plt.figure(figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.45))
    fig.subplots_adjust(left=0.12, right=0.92, top=0.85, bottom=0.15)
    gs = fig.add_gridspec(1, 5, width_ratios=[1, 0.07, 0.18, 1, 0.07], height_ratios=[1])
    # gs.update(wspace=0.05)
    ax0 = fig.add_subplot(gs[0])
    cb0 = fig.add_subplot(gs[1])
    ax1 = fig.add_subplot(gs[3])
    cb1 = fig.add_subplot(gs[4])
    maxVal = max(F9LossData['data'].max(), abs(F9LossData['data'].min()))
    mesh0 = ax0.pcolormesh(F9LossData['timeEdges'], F9LossData['zEdges'],
                        F9LossData['data'], cmap='RdBu_r', norm=SymLogNorm(1e-2, vmin=-maxVal, vmax=maxVal), rasterized=True)
    # plt.colorbar()
    maxVal = max(F10LossData['data'].max(), abs(F10LossData['data'].min()))
    mesh1 = ax1.pcolormesh(F10LossData['timeEdges'], F10LossData['zEdges'], F10LossData['data'],
                        cmap='RdBu_r', norm=SymLogNorm(1e-2, vmin=-maxVal, vmax=maxVal),
                        rasterized=True)
    #                        , vmax=0.2)
    fig.colorbar(mesh0, cax=cb0)
    fig.colorbar(mesh1, cax=cb1)
    ax0.set_title('Variation in losses due to calcium\ntreatment in F9 simulation')
    ax1.set_title('Variation in losses due to calcium\ntreatment in F10 simulation')
    ax0.set_xlabel('t [s]')
    ax1.set_xlabel('t [s]')
    ax0.set_ylabel('Height [Mm]')
    return fig
fig = plot_loss_variation(F9PanelData, F10PanelData)
lFig = chRT.save_figure('LossVariation', fig, fext='.pgf', dpi=500)
lFig.caption = r'The absolute relative change of the radiative losses considered here due to the two different calcium treatments in each of the simulations (i.e. the product of the two panels in each of Figs.~\ref{Fig:F9LossComparison} and \ref{Fig:F10LossComparison}).'
lFig.short_caption = r'Effect of calcium losses on total radiative losses in the two simulations.'
\end{pycode}
\py[TimeDepRT]|chRT.get_figure('LossVariation')|
%spell-checker: enable

Whilst the term ``radiative losses'' is often used to describe the effects of radiation on the energy balance of the plasma, these effects are not uniquely negative.
In many regions of the plasma, absorption leads to a net gain in plasma energy, especially considering each transition on an independent basis.
It is therefore difficult to immediately assess the effect that a change in radiative loss has on the system.
For this we adopt an absolute relative difference metric computed following
\begin{equation}
    \frac{\sum_{i\in\mathcal{C}}|\textnormal{loss}_{i,\,\textnormal{LE}}| - \sum_{i\in\mathcal{C}}|\textnormal{loss}_{i,\,\textnormal{LI}}|}{\sum_{i\in\mathcal{C}}|\textnormal{loss}_{i,\,\textnormal{LE}}|}
\end{equation}
where $\mathcal{C}$ is the set of calcium lines used on our model atom, and $\textnormal{loss}_i$ is the volumetric radiative loss of transition $i$.
This metric therefore quantifies the effect on the total energy being redistributed throughout the simulation (or leaving the simulation) from the different treatments of the \Caii{} lines.
To assess the importance of this it is also essential to know the impact of the \Caii{} lines on the total energy balance of the simulation.
Thus we also compute
\begin{equation}
    \frac{\sum_{i\in\mathcal{C}}|\textnormal{loss}_{i,\,\textnormal{\Radyn{}}}|}{\sum_j|\textnormal{loss}_{j,\,\textnormal{\Radyn{}}}|},
\end{equation}
which describes the proportion of all radiative losses considered with a detailed NLTE treatment in \Radyn{} (hydrogen, helium, and calcium, lines and continua) due to the calcium lines.
These two metrics are plotted in the left- and right-hand panels respectively of Figs.~\ref{Fig:F9LossComparison} and \ref{Fig:F10LossComparison} for the F9 and F10 simulations respectively.

Looking first at the F9 simulation shown in Fig.~\ref{Fig:F9LossComparison}, there is a significant difference between the calcium losses in the two treatments during heating (0--\SI{10}{\second}), with relative differences primarily in excess of 50\,\% and peaking as high as 1000\,\% in the 0.6--\SI{1.75}{\mega\m} region.
This is not surprising given the difference in the outgoing profiles shown in Fig.~\ref{Fig:F9Profiles}.
This difference remains important (typically 10--70\,\%) above an altitude of \SI{1}{\mega\metre} throughout the entire simulation.
The right-hand panel shows that these losses represent the largest proportion of the total radiative losses in the 0.6--\SI{1}{\mega\metre} region (after heating has ended).
This is also the region in which the radiative losses between the two treatments agree the best, with differences below 10\,\% over most of this region.
Nevertheless, in the region above \SI{1}{\mega\metre} where there is significant disagreement between the two treatments, the calcium losses typically represent in excess of 8\,\% of the total.

The effects are quite similar in the F10 simulation.
During energy deposition the region where the difference between the two treatments is largest is a smaller band, which is centred on $\sim$\SI{1.2}{\mega\metre}.
The variation here is 30--50\,\%.
This location is in agreement with the line-core formation region shown in the contribution functions.
This region then expands significantly due to evaporation as the beam heating ends.
Similarly to the F9 simulation, the region where the calcium lines represent the largest proportion of the total radiative losses is between 0.6 and \SI{1}{\mega\metre} at later times in the simulation, and this is once again the region where the two treatments best agree (with a similar discrepancy to the F9 case).
In the region above this, where the difference between the two treatments is less but still significant, the calcium line losses typically represent 5--20\,\% of the total radiative losses.

For both of the simulations presented here there appears to be a similar difference between the LI and LE calcium treatments.
We can obtain a clearer estimate of the effects of the calcium treatment on the total radiative losses by plotting the product of the left- and right-hand panels of Figs.~\ref{Fig:F9LossComparison} and \ref{Fig:F10LossComparison}.
These are plotted in Fig.~\ref{Fig:LossVariation} and confirm our conclusions.
In both cases, throughout the upper chromosphere there is a variation in total radiative losses of up to 15\,\%.
Time-averaging this variation suggests that the average difference is larger in the F9 simulation than the F10 simulation, although these are both of the same order of magnitude.
This difference is likely due to a larger fraction of the total radiative losses from this region being mediated by the hydrogen transitions in the more energetic simulation, as a larger proportion of the calcium populations are ionised into the \Caiii{} state.
From these simulations, we can suggest that it is likely that using a self-consistent LI treatment (where the changes in radiative losses directly affect the hydrodynamic evolution) could produce a change in energy balance in the chromosphere of 10--15\,\%.
This is sufficiently large to noticeably modify the atmospheric evolution, which would further affect the outgoing calcium line profiles and formation heights, but also other chromospheric lines, such as the hydrogen Balmer series.


\section{Case Study: Is Full Time-Dependence Necessary?}\label{Sec:TimeDepSE}

\emph{The work in this section was undertaken in collaboration with P. Heinzel and J. Kašparová, in parallel with the study of \Caii{} photoionisation, as a result of the International Space Science Institute (ISSI) meeting: ``Interrogating Field-Aligned Solar Flare Models: Comparing, Contrasting and Improving'' led by G.S. Kerr and V. Polito.}

It has been repeatedly shown that a time-dependent treatment of the hydrogen populations is necessary in RHD simulations.
This was first investigated in wave heated chromospheric simulations by \citet{Carlsson2002}, who found a settling time for hydrogen to return to equilibrium ionisation of the order of thousands of seconds.
\citet{Brown2018} also compared the hydrogen line profiles, computed with \Radyn{}'s approximate PRD and time-dependence, and also with statistical equilibrium using the full PRD treatment of RH (i.e. treating each atmospheric subsequent snapshot in statistical equilibrium).
They found that the time-dependence had a more significant effect than PRD on the Lyman lines, and could not be ignored.
More recently \citet{Kerr2019a} have investigated the effects of a time-dependent treatment of the level populations of Mg\,\textsc{ii}, and found that whilst there were differences between the statistical equilibrium and time-dependent treatments, the statistical equilibrium treatment was sufficient for most stages of the flare models investigated.
They conclude that for this line priority should be given to the PRD treatment.
Similarly, \citet{Leenaarts2012a} found that for a correct synthesis of H$\alpha$ from three-dimensional RMHD models, only an equation of state taking into account the non-equilibrium ionisation and its effects on the electron density is necessary, and under this condition a full three-dimensional treatment is more important than complete time-dependence.
\citet{Wedemeyer-Bohm2011} investigated the non-equilibrium ionisation of calcium in quiet RADYN simulations and found that whilst the statistical equilibrium and time-dependent treatments gave different ionisation fractions, the difference in the synthesised line profiles was hardly discernable.

It is therefore important to assess the importance of a time-dependent treatment of \Caii{} in solar flare models.
In the following, we shall briefly summarise our investigation of the importance of treating \Caii{} with time-dependence in the RHD model used for the comparison of the \Radyn{} and FLARIX codes presented in \citet{Kasparova2019}.
This simulation utilises a set of features common to both codes, considering only hydrogen and calcium in detailed radiative transfer, and using an analytic ``Emslie'' beam formalism.
The beam flux is modulated to have a symmetric triangular time profile, lasting \SI{20}{\second} and peaking at \SI{10}{\second} depositing a total of $1\times{}10^8\si{\joule\per\square\metre}$ \footnote{$1\times{}10^{11}\si{\erg\per\square\centi\metre}$}.
A spectral index of 3 and low-energy cut-off of \SI{20}{\kilo\electronvolt} was also chosen, and similarly to the models shown previously the initial atmosphere was based on the VAL3C model of \citet{Vernazza1981}.

% spell-checker: disable
% \begin{pycode}[TimeDepRT]
% timesToSim = [2, 5, 10, 15, 20, 25]
% radOutput = []
% for t in timesToSim:
%     idx10s = np.searchsorted(atmost.time, t)

%     atmos = lw.Atmosphere.make_1d(scale=lw.ScaleType.Geometric, depthScale=np.copy(atmost.z1[idx10s]),
%                                   temperature=np.copy(atmost.tg1[idx10s]),
%                                   vlos=np.copy(atmost.vz1[idx10s]),
%                                   vturb=np.ones_like(atmost.tg1[idx10s]) * 2e3,
%                                   ne=np.copy(atmost.ne1[idx10s]),
%                                   nHTot=(atmost.d1[idx10s] / (lw.DefaultAtomicAbundance.massPerH * lw.Amu)),
%                         )
%     atmos.quadrature(5)

%     from lightweaver.rh_atoms import H_6_atom, C_atom, O_atom, OI_ord_atom, Si_atom, Al_atom, Fe_atom, FeI_atom, MgII_atom, N_atom, Na_atom, S_atom, CaII_atom, He_9_atom
%     from MsLightweaverAtoms import H_6, CaII, H_6_nasa, CaII_nasa, H_6_noLybb

%     Atoms = [H_6(), CaII(), He_9_atom(), C_atom(), O_atom(), Si_atom(), Fe_atom(),
%                     MgII_atom(), N_atom(), Na_atom(), S_atom()]
%     AtomsNoLybb = [H_6_noLybb(), CaII(), He_9_atom(), C_atom(), O_atom(), Si_atom(), Fe_atom(),
%                     MgII_atom(), N_atom(), Na_atom(), S_atom()]
%     aSet = lw.RadiativeSet(Atoms)
%     aSet.set_detailed_static('H')
%     aSet.set_active('Ca')
%     spect = aSet.compute_wavelength_grid()
%     eqPops = aSet.compute_eq_pops(atmos)
%     eqPops['H'][...] = atmost.nh1[idx10s, :]

%     aSetNoLy = lw.RadiativeSet(AtomsNoLybb)
%     aSetNoLy.set_detailed_static('H')
%     aSetNoLy.set_active('Ca')
%     spectNoLy = aSetNoLy.compute_wavelength_grid()
%     eqPopsNoLy = aSetNoLy.compute_eq_pops(atmos)
%     eqPopsNoLy['H'][...] = atmost.nh1[idx10s, :]

%     ctx = lw.Context(atmos, spect, eqPops, initSol=lw.InitialSolution.Lte, conserveCharge=False, Nthreads=12)
%     ctxNoLy = lw.Context(atmos, spectNoLy, eqPopsNoLy, initSol=lw.InitialSolution.Lte, conserveCharge=False, Nthreads=12)

%     for i in range(500):
%         dJ = ctx.formal_sol_gamma_matrices()
%         if i < 10:
%             continue
%         delta = ctx.stat_equil()
%         if dJ < 3e-3 and delta < 1e-3:
%             print(i)
%             break
%     for i in range(500):
%         dJ = ctxNoLy.formal_sol_gamma_matrices()
%         if i < 10:
%             continue
%         delta = ctxNoLy.stat_equil()
%         if dJ < 3e-3 and delta < 1e-3:
%             print(i)
%             break

%     radOutput.append({'Full': np.copy(ctx.spect.I), 'NoLybb': np.copy(ctxNoLy.spect.I)})
% \end{pycode}

\begin{pycode}[TimeDepRT]
from matplotlib.ticker import MaxNLocator
flarixComp = zarr.convenience.open(chRT.data_file('FlarixCompHard/FlarixCompHardFull.zip'), 'r')
flarixCompNoLy = zarr.convenience.open(chRT.data_file('FlarixCompHard/FlarixCompHardNoLybb.zip'), 'r')
with open(chRT.data_file('FlarixCompHard/RadynFlarixCompHardStatEqLightweaver.pickle'), 'rb') as pkl:
    flarixCompSe = pickle.load(pkl)

plotTimes = [2, 5, 10, 15, 20, 25]
fig, ax = plt.subplots(2, 3, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.7))
fig.subplots_adjust(left=0.12, right=0.99)
ax = ax.ravel()

maxI = flarixCompNoLy['Iwave'][...].max()
wave = flarixCompSe['wavelength']
waveNoLy = flarixCompSe['wavelengthNoLy']
ca = CaII()

for i, t in enumerate(plotTimes):
    zarrIdx = np.searchsorted(flarixComp['time'][...], t)
    label = 'LI Time-Dep' if i == len(plotTimes) - 1 else None
    ax[i].plot(wave - ca.lines[-1].lambda0, flarixComp['Iwave'][zarrIdx, :, -1], c='C1', linewidth=1.0, label=label)
    label = 'LE Time-Dep' if i == len(plotTimes) - 1 else None
    ax[i].plot(waveNoLy - ca.lines[-1].lambda0, flarixCompNoLy['Iwave'][zarrIdx, :, -1], c='C2', linewidth=1.0, label=label)
    label = 'LI Stat Eq' if i == len(plotTimes) - 1 else None
    ax[i].plot(wave - ca.lines[-1].lambda0, flarixCompSe['radOutput'][i]['Full'][:, -1], '--', c='C1', label=label)
    label = 'LE Stat Eq' if i == len(plotTimes) - 1 else None
    ax[i].plot(waveNoLy - ca.lines[-1].lambda0, flarixCompSe['radOutput'][i]['NoLybb'][:, -1], '--', c='C2', label=label)
    ax[i].set_xlim(-0.07, 0.07)
    ax[i].set_ylim(None, maxI * 1.05)
    ax[i].set_title('{:.1f} s'.format(t))

    if not (i == 0 or i == 3):
        ax[i].set_yticklabels([])
    else:
        ax[i].set_ylabel('Specific Intensity [SI]')

    if i < 3:
        ax[i].set_xticklabels([])
    else:
        ax[i].xaxis.set_major_locator(MaxNLocator(3))
        ax[i].set_xlabel(r'$\Delta\lambda$ [nm]')

    if i == len(plotTimes) - 1:
        ax[i].legend(frameon=False, fontsize=10, loc=(0.03, 0.45),
                     handlelength=1.5, handletextpad=0.5, columnspacing=1.5)

lFig = chRT.save_figure('TimeDepSEComparison', fig, fext='.pgf')
lFig.caption = r'Comparison of time-dependent and statistical equilibrium treatments for the Ca\,\textsc{ii} \SI{854.2}{\nano\metre} line for LI and LE treatments in the simulation described in Section~\ref{Sec:TimeDepSE}. The time-dependent treatments are shown with solid lines, and the statistical equilibrium treatments with dashed lines. Orange is used for the LI treatment, and green for the LE treatment.'
lFig.short_caption = r'Comparison of time-dependent and statistical equilibrium treatment of \CaLine{}.'
\end{pycode}

\py[TimeDepRT]|chRT.get_figure('TimeDepSEComparison')|
% spell-checker: enable

In Fig.~\ref{Fig:TimeDepSEComparison} we present a comparison of both the LI and LE treatments of \CaLine{} line at different times in this simulation, having applied both time-dependent and statistical equilibrium treatments to the calcium populations.
In all cases the hydrogen populations were loaded from a fully time-dependent run and are used in \Lw{}'s ``detailed static'' mode to provide the correct radiation field.
The time-dependent treatments are considered as expected reference solutions shown with solid lines, whilst the statistical equilibrium treatments are shown with dashed lines.
Comparing the time-dependent LI (orange) and LE (green) line profiles, we see a very similar picture to that presented by our previous simulations, with the peak intensity during heating being higher in the LE case and the LI model remaining more dramatically double-peaked at later times.
Instead comparing the time-dependent and statistical equilibrium line profiles, we find very good agreement for all but the $t=\SI{2}{\second}$ snapshot, and the LI case of the $t=\SI{5}{\second}$ snapshot.
For the latter of these, the line shape is correct, but the intensity of the statistical equilibrium case is a few per cent lower than that of the full time-dependent treatment.
At $t=\SI{2}{\second}$ the difference between the two different LI treatments is greater than the difference between the LE treatments, but for both the LI and LE cases the statistical equilibrium lines are narrower and less pronounced than their time-dependent counterparts.

For this particular simulation, after the first few seconds of heating, the statistical equilibrium treatment is perfectly valid with no obvious defects.
Clearly, this one simulation does not represent all RHD flare simulations, but we have empirically found this to be true when testing multiple timesteps from the simulations used in the previous sections.


\section{Case Study: Partial Frequency Redistribution}\label{Sec:TimeDepPrd}

As highlighted by \citet{Brown2018}, when considering the hydrogen Lyman lines it would be a significant improvement to simultaneously handle full time-dependence and PRD.
It is possible that this could prove important for the energy balance of the line-forming regions, in a similar manner to the photoionisation effects discussed previously.
Indeed, any significant variation in the hydrogen Lyman series may affect the populations of calcium and other species through photoionisation.
\Ha{} could also be affected through modifications of the level populations associated with the Lyman lines, as discussed by \citet{Leenaarts2012a}.
They investigated the same Doppler-like PRD approximation that was used in our F9 and F10 \Radyn{} simulations presented in Sec.~\ref{Sec:CaiiPhotoionisation} and found that it was sufficient to obtain correct H$\alpha$ line profiles in the quiet Sun case.
The version of \Radyn{} used by \citet{Brown2018} applied this same Doppler-like approximation.
We term this treatment ``Doppler-like'' as it consists of the removal of natural radiative and van der Waals broadening terms, but the linear Stark broadening terms, that can be important in flares \citep[e.g.][]{DeFeiter1975}, are left in the model.

\subsection{Modifying Our \Lw{}-based Model to Support PRD}

The \Lw{} framework supports both time-dependence and PRD lines, thus we can attempt to modify the tool built in this chapter to also include PRD effects.
\citet{Hong2019} included some of the effects of partial redistribution with simultaneous time-dependent populations by extracting the hydrogen level populations from \Radyn{} and computing the PRD line profile ratio with RH.
Using this method, the modified radiation field and line emission profile will not be taken into account in the calculation of the radiative rates used to update the populations.
In the following, we attempt to treat this problem self-consistently.

Our hydrogen model atom is modified by restoring the natural and van der Waals broadening terms in the definitions of the Ly$\alpha$ and Ly$\beta$ spectral line models.
These are the terms that were previously removed to render the line profiles Doppler-like.
We then solve the statistical equilibrium problem for the initial atmosphere in PRD, and then update the PRD line emission ratio $\rho_{ij}$ during each timestep based on the current atmospheric parameters and radiation field, performing several updates of $\rho_{ij}$ and formal solutions with fixed populations, following the usual process described in Sec.~\ref{Sec:Prd}.
Unfortunately, this basic approach proved to have incredibly poor convergence.
Many timesteps failed to converge or the iterative scheme would enter a loop of repeatedly passing through the same states, getting no closer to the convergence threshold.
Of the timesteps that do converge, many take an exceedingly large number of iterations.

These convergence problems are somewhat unexpected due to the reliability of the methods used here when applied to statistical equilibrium problems \citep[e.g.][]{Uitenbroek2001}.
Unfortunately, we are faced with an additional problem when performing time-dependent simulations, especially in the reprocessing context used here: when a timestep fails to converge we lose the ability to investigate later in the simulation, as the populations at every timestep are dependent on those preceding.
When reprocessing snapshots of an RHD simulation using a statistical equilibrium treatment, a failure for one of these to converge does not limit the analysis of any other snapshot.

The following procedure was found to be relatively robust, and was sufficient to reprocess the complete F9 simulation presented previously.
At the start of each timestep, when the populations are advected from the previous grid to the next, the line emission ratio $\rho_{ij}$ is interpolated onto the new grid.
Inherent to this assumption is the idea that $\rho_{ij}$ will not change too drastically between subsequent timesteps.
The time-dependent problem is then solved to our normal tolerance whilst keeping $\rho_{ij}$ fixed at its interpolated values.
Once converged, we continue to compute the time-dependent population update, whilst now interleaving iterations of updating $\rho_{ij}$ following the usual process.

In the F9 simulation this approach proves to be rapidly convergent at early times, but far less so at later times during the cooling phase.
Initially this appears unintuitive, but the non-thermal collisional rates from the electron beam depositing energy in the simulation are combined with thermal collisional rates during the heating phase and likely reduce the effects of PRD on these lines.
At later times the Lyman line forming regions are likely to be less collisional, whilst the line remains strong with the radiative rates representing a significant component of the population transition rate.
Similar convergence behaviour occurred when reprocessing the F10 simulation, but the convergence deteriorates sooner and despite adjustments to the number of PRD sub-iterations taken, the model usually fails to converge around $t=\SI{3.75}{\second}$.

\subsection{Results}

%spell-checker: disable
\begin{pycode}[TimeDepRT]
from MsLightweaverAtoms import H_6
def plot_prd_profiles(liData, prdData, radyn):
    plotTimes = [5, 11, 20, 40]
    fig, ax = plt.subplots(1, 4, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.40),
                           sharex=True, sharey=True,
                           gridspec_kw={'wspace': 0.1, 'width_ratios':[1,1,1,1]})
    fig.subplots_adjust(left=0.12, right=0.99)
    ax = ax.ravel()

    lineData = line_intensity_with_cont(radyn, 0, -1)
    h = H_6()
    wavelength = liData['wavelength'][...]
    wavelengthPrd = prdData['wavelength'][...]
    for i, time in enumerate(plotTimes):
        lwIdx = np.searchsorted(liData['time'], time)
        radynIdx = np.searchsorted(radyn.time, time)
        lambda0 = h.lines[0].lambda0

        if i == 0:
            ax[i].plot(lineData[0].value - lambda0, lineData[1][radynIdx], label='RADYN')
            ax[i].plot(wavelength - lambda0, liData['Iwave'][lwIdx, :, -1], '--', label='Lw CRD')
            ax[i].plot(wavelengthPrd - lambda0, prdData['Iwave'][lwIdx, :, -1], '--', label='Lw PRD')
        else:
            ax[i].plot(lineData[0].value - lambda0, lineData[1][radynIdx])
            ax[i].plot(wavelength - lambda0, liData['Iwave'][lwIdx, :, -1], '--')
            ax[i].plot(wavelengthPrd - lambda0, prdData['Iwave'][lwIdx, :, -1], '--')

        ax[i].set_title('{:.2f} s'.format(time))
        ax[i].xaxis.set_minor_locator(AutoMinorLocator())

    ax[0].set_yscale('log')
    ax[0].set_ylim(1e-11, 4e-9)
    ax[0].set_xlim(-0.06, 0.06)

    ax[0].yaxis.offsetText.set_visible(False)
    ax[0].set_ylabel('Specific Intensity [SI]')
    for a in ax:
        a.set_xlabel('$\Delta\lambda$ [nm]')
    fig.subplots_adjust(bottom=0.15)
    fig.legend(*ax[0].get_legend_handles_labels(), loc=(0.82,0.63), frameon=False,
               handletextpad=0.5, handlelength=1.5, fontsize=9)#, bbox_to_anchor=(0.5,0.53))
    return fig

def plot_prd_K_profiles(liData, prdData, radyn):
    plotTimes = [5, 11, 20, 40]
    fig, ax = plt.subplots(1, 4, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.40),
                           sharex=True, sharey=True,
                           gridspec_kw={'wspace': 0.1, 'width_ratios':[1,1,1,1]})
    fig.subplots_adjust(left=0.12, right=0.99)
    ax = ax.ravel()

    lineData = line_intensity_with_cont(radyn, 17, -1)
    ca = CaII()
    wavelength = liData['wavelength'][...]
    wavelengthPrd = prdData['wavelength'][...]
    for i, time in enumerate(plotTimes):
        lwIdx = np.searchsorted(liData['time'], time)
        radynIdx = np.searchsorted(radyn.time, time)
        lambda0 = ca.lines[1].lambda0

        if i == 0:
            ax[i].plot(lineData[0].value - lambda0, lineData[1][radynIdx], label='RADYN')
            ax[i].plot(wavelength - lambda0, liData['Iwave'][lwIdx, :, -1], '--', label='Lw CRD')
            ax[i].plot(wavelengthPrd - lambda0, prdData['Iwave'][lwIdx, :, -1], '--', label='Lw PRD')
        else:
            ax[i].plot(lineData[0].value - lambda0, lineData[1][radynIdx])
            ax[i].plot(wavelength - lambda0, liData['Iwave'][lwIdx, :, -1], '--')
            ax[i].plot(wavelengthPrd - lambda0, prdData['Iwave'][lwIdx, :, -1], '--')

        ax[i].set_title('{:.2f} s'.format(time))
        ax[i].xaxis.set_minor_locator(AutoMinorLocator())

    ax[0].set_yscale('log')
    ax[0].set_ylim(5e-10, 14e-8)
    ax[0].set_xlim(-0.075, 0.075)

    ax[0].yaxis.offsetText.set_visible(False)
    ax[0].set_ylabel('Specific Intensity [SI]')
    for a in ax:
        a.set_xlabel('$\Delta\lambda$ [nm]')
    fig.subplots_adjust(bottom=0.15)
    fig.legend(*ax[0].get_legend_handles_labels(), loc=(0.82,0.63), frameon=False,
               handletextpad=0.5, handlelength=1.45, fontsize=9)#, bbox_to_anchor=(0.5,0.53))
    return fig

from matplotlib.ticker import SymmetricalLogLocator
def plot_K_losses(atmost, liData, prdData):
    plotTimes = [5, 11, 20, 40]
    fig, ax = plt.subplots(1, 4, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.40),
                           sharex=True, sharey=True,
                           gridspec_kw={'wspace': 0.1, 'width_ratios':[1,1,1,1]})
    fig.subplots_adjust(left=0.08, right=0.99)
    ax = ax.ravel()
    caKIndex = 11

    lineData = line_intensity_with_cont(radyn, 17, -1)
    for i, time in enumerate(plotTimes):
        lwIdx = np.searchsorted(liData['time'], time)
        atmostIdx = np.searchsorted(atmost.time, time)

        if i == 0:
            ax[i].plot(liData['losses'][lwIdx, caKIndex, :],
                       atmost.z1[atmostIdx] / 1e6, c='C1', label='Lw CRD')
            ax[i].plot(prdData['losses'][lwIdx, caKIndex, :],
                       atmost.z1[atmostIdx] / 1e6, '--', c='C2', label='Lw PRD')
        else:
            ax[i].plot(liData['losses'][lwIdx, caKIndex, :],
                       atmost.z1[atmostIdx] / 1e6, c='C1')
            ax[i].plot(prdData['losses'][lwIdx, caKIndex, :],
                       atmost.z1[atmostIdx] / 1e6, '--', c='C2')

        ax[i].set_title('{:.2f} s'.format(time))
        # ax[i].xaxis.set_minor_locator(AutoMinorLocator())

    ax[0].set_xscale('symlog', linthresh=1e-5)
    ax[0].set_ylim(0.2, 2.0)
    ax[0].set_xlim(-1e-1, 1e-1)

    # ax[0].yaxis.offsetText.set_visible(False)
    ax[0].set_ylabel('Height [Mm]')
    for a in ax:
        a.set_xlabel('Loss [W\,m$^{-3}$]')
        a.set_xticks([-1e-2, -1e-4, 0, 1e-4, 1e-2])
    fig.subplots_adjust(bottom=0.17)
    fig.legend(*ax[0].get_legend_handles_labels(), loc=(0.86,0.48), frameon=False,
               handletextpad=0.5, handlelength=1.5, fontsize=9)#, bbox_to_anchor=(0.5,0.53))
    return fig

prdData = zarr.convenience.open(chRT.data_file('Flat1e9NoIncRadPrdFineGridThesis.zip'), 'r')
fig = plot_prd_profiles(liData, prdData, radyn)
lFig = chRT.save_figure('F9LyaProfiles', fig, fext='.pgf')
lFig.caption = r'Comparison of the RADYN CRD, \Lw{} CRD, both with reduced broadening to approximate PRD, and \Lw{} PRD treatments of the Ly$\alpha$ line in the F9 model. Lw is used as shorthand for \Lw{}.'
lFig.short_caption = r'Comparison of the CRD and PRD treatments of the Ly$\alpha$ line in the F9 model.'

fig = plot_prd_K_profiles(liData, prdData, radyn)
lFig = chRT.save_figure('F9KProfiles', fig, fext='.pgf')
lFig.caption = r'Comparison of the RADYN CRD, \Lw{} CRD, and PRD treatments of the Ca\,\textsc{ii} K line in the F9 model. Lw is used as a shorthand for \Lw{}.'
lFig.caption = r'Comparison of the CRD and PRD treatments of the Ca\,\textsc{ii} K line in the F9 model.'

fig = plot_K_losses(atmost, liData, prdData)
lFig = chRT.save_figure('F9KLossesPrd', fig, fext='.pgf')
lFig.caption = r'Comparison of the chromospheric radiative losses under CRD and PRD treatments of the Ca\,\textsc{ii} K line in the F9 model. A negative value indicates a radiative loss and a positive value a radiative gain. Lw is used as a shorthand for \Lw{}.'
lFig.short_caption = r'Comparison of the chromospheric radiative losses under CRD and PRD treatments of the \Caii{} K line in the F9 model.'
\end{pycode}

\py[TimeDepRT]|chRT.get_figure('F9LyaProfiles')|

\py[TimeDepRT]|chRT.get_figure('F9KProfiles')|

\py[TimeDepRT]|chRT.get_figure('F9KLossesPrd')|
%spell-checker: enable

The Ly$\alpha$ line computed in the reprocessed F9 simulation, both with approximate (dashed orange) and fully modelled PRD effects (dashed green), is shown in Fig.~\ref{Fig:F9LyaProfiles}.
It is compared against the \Radyn{} solution (blue), using the same approximate treatment.
Once again, our CRD treatment of the problem with \Lw{} yields very good results when compared to \Radyn{} as a reference solution.
Other than the line wings at $t=\SI{5}{\second}$ and to a lesser extent at $t=\SI{40}{\second}$ the PRD and CRD (with reduced broadening terms) match well, although the PRD line core at $t=\SI{20}{\second}$ is a fair amount deeper than the CRD case.
This is encouraging for the use of this approximation, especially in light of the difficulties converging the PRD problem in time-dependent simulations.
Furthermore, the PRD solution, due to its poor convergence at later times, is extremely computationally costly when compared to the CRD solution, taking close to two orders of magnitude more CPU time (73 vs 1.2 wall hours\footnote{Wall hours refer to a real world elapsed time, despite the fact multiple CPU cores are used in the problem. This metric also captures the fact that the implementation of updating $\rho_{ij}$ is less parallelised in \Lw{} than the CRD MALI method which dominates the runtime of the CRD case (average $\sim65$\,\% utilisation of 12 threads, rather than 98\,\%).} on \emph{hephaistos}).

Ly$\alpha$ is not the only line affected by PRD in this simulation; we also investigated the effects on Ly$\beta$ and the \Caii{} H and K resonance lines.
Ly$\beta$ was found to have very good agreement between the approximate and complete PRD treatments in \Lw{}, similar or better than that found for Ly$\alpha$.
The agreement between \Radyn{} and the \Lw{} CRD treatment was also extremely good, as in the Ly$\alpha$ case.
\Caii{} H and K are affected by PRD effects but also by the use of the LI treatment, albeit less than \CaLine{}, and this is likely due to the lack of overlap between Ly$\alpha$ and the \Caii{} resonance continuum.
In Fig.~\ref{Fig:F9KProfiles}, the variation of the \Caii{} K line computed using CRD with the LI treatment and PRD with the LI treatment is shown.
The differences between the CRD line profiles and the \Radyn{} line profiles are due to the LI treatment.
The PRD line cores agree very well with the CRD LI treatment, but as expected when a significant proportion of the scattering is coherent the line wings deepen and then slowly return to the same continuum level as the CRD case.

\citet{Uitenbroek2002} undertook similar tests in a wave-heated quiet Sun \Radyn{} simulation and looked at the radiative losses in the \Caii{} K line when treated in PRD (under statistical equilibrium).
In the chromosphere these losses were found to vary between the CRD and PRD treatments by a factor of 2--5.
Qualitatively, there is a smaller difference in the \Caii{} wings in our flare simulation than their wave-heated model.
The losses between these two different treatments in the chromosphere are shown in Fig.~\ref{Fig:F9KLossesPrd}.
The differences in the radiative losses are most significant at $t=\SI{5}{\second}$ with the inversion of the sign of the losses between the PRD and CRD treatments around \SI{1}{\mega\metre}.
Whilst less significant, at the other times shown there is also clear variation in radiative losses due to the treatment of the \Caii{} resonance lines in PRD, typically decreasing these relative to their CRD values.

\subsection{Discussion}

Whilst we have not attempted to implement this, it is possible that applying a direct, rather than iterative solution for evaluating the emission profile ratio may be more stable in this situation.
The iterative method, implemented as first presented in \citet{Uitenbroek2001}, tends to have very good convergence when used in the statistical equilibrium case, whilst being less computationally expensive and much easier to apply in multi-dimensional geometry.
It is plausible here that the effective damping of the population update equations of the time-dependent kinetic equilibrium equations relative to statistical equilibrium is reducing the convergence rate, due to the slower rate (per iteration) at which the populations evolve.
It may therefore be worth investigating the direct solution in the hope that by more rapidly converging to the correct solution for the emission profile the populations do not pass through intermediate states that are not ``valid'' i.e. states that are intermediate to the iteration scheme, but do not occur at any point in the real world system we are computing.
It is plausible that many of the intermediate states that occur in both time-dependent and statistical equilibrium calculations are not states that occur naturally, instead resulting from our numerical treatment of the system.

When additional iteration processes such as PRD and charge conservation are applied (leading to the application of three simultaneous iterative processes to the problem), whilst being combined with the damped nature of the time-dependent population update, it appears that cycles in the global iteration procedure can occur quite frequently, and no method that we have found reliably prevents these (including interleaving basic $\Lambda$-iterations and applying Ng acceleration \citep{Ng1974}).
\citet{Avrett2008} also comment that strong lines can pose problems for the convergence of ALI schemes and propose a scheme for computing strong PRD lines by solving a linear system of simultaneous equations for the rate and transfer equations, whilst solving for weaker transitions by an ALI method.
If this approach is reformulated and implemented for the time-dependent case, it is possible that it will not suffer the same convergence problems that were encountered in this section, especially given the strength of these lines in flare-heated atmospheres.

\section{Digging Deeper: Time-Dependent Response Functions}

%spell-checker: disable
\begin{pycode}[TimeDepRT]
from matplotlib.ticker import MaxNLocator

def rf_sym_range(rf):
    vmin = rf.min()
    vmax = rf.max()
    vmaxAbs = max(abs(vmin), abs(vmax))
    return vmaxAbs

def plot_cf_rf_comparison(cfnData, rfTempLI, rfVlosLI,
                          rfTempLE, rfVlosLE, wavelengthLI, wavelengthLE):
    fig, ax = plt.subplots(2, 3, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.6))
    fig.subplots_adjust(left=0.12, right=0.99, hspace=0.09, wspace=0.12)

    wavelengthEdgesLI = np.concatenate(([wavelengthLI[0]],
                                        0.5 * (wavelengthLI[1:] + wavelengthLI[:-1]),
                                        [wavelengthLI[-1]]))
    wavelengthEdgesLE = np.concatenate(([wavelengthLE[0]],
                                        0.5 * (wavelengthLE[1:] + wavelengthLE[:-1]),
                                        [wavelengthLE[-1]]))

    ca = CaII()
    lambda0 = ca.lines[-1].lambda0

    ax[0, 0].pcolormesh(cfnData['wavelengthEdges'], cfnData['heightEdges'], cfnData['LI'],
                        rasterized=True, cmap='Blues',
                        norm=SymLogNorm(linthresh=5e-14, vmin=1e-20, vmax=cfnData['maxVal']))
    ax[0, 0].plot(cfnData['wavelengthTau1'], cfnData['tau1LI'], c='r', alpha=0.5)
    ax[0, 0].set_xlim(-0.1, 0.1)
    ax[0, 0].set_ylim(None, 2.4)
    ax[0, 0].set_title('Contribution Function')
    vmaxAbs = rf_sym_range(rfTempLI['rf'])
    ax[0, 1].pcolormesh(wavelengthEdgesLI - lambda0, cfnData['heightEdges'], rfTempLI['rf'],
                        rasterized=True, cmap='RdBu_r',
                        norm=SymLogNorm(linthresh=1e-14, vmin=-vmaxAbs, vmax=vmaxAbs))
    ax[0, 1].plot(cfnData['wavelengthTau1'], cfnData['tau1LI'], c='r', alpha=0.5)
    ax[0, 1].set_xlim(-0.1, 0.1)
    ax[0, 1].set_ylim(None, 2.4)
    ax[0, 1].set_title('Temperature Response')
    # vmaxAbs = rf_sym_range(rfVlosLI['rf'])
    ax[0, 2].pcolormesh(wavelengthEdgesLI - lambda0, cfnData['heightEdges'], rfVlosLI['rf'],
                        rasterized=True, cmap='RdBu_r',
                        norm=SymLogNorm(linthresh=1e-14, vmin=-vmaxAbs, vmax=vmaxAbs))
    ax[0, 2].plot(cfnData['wavelengthTau1'], cfnData['tau1LI'], c='r', alpha=0.5)
    ax[0, 2].set_xlim(-0.1, 0.1)
    ax[0, 2].set_ylim(None, 2.4)
    ax[0, 2].set_title('Velocity Response')

    ax[1, 0].pcolormesh(cfnData['wavelengthEdges'], cfnData['heightEdges'], cfnData['LE'],
                        rasterized=True, cmap='Blues',
                        norm=SymLogNorm(linthresh=5e-14, vmin=1e-20, vmax=cfnData['maxVal']))
    ax[1, 0].plot(cfnData['wavelengthTau1'], cfnData['tau1LE'], c='r', alpha=0.5)
    ax[1, 0].set_xlim(-0.1, 0.1)
    ax[1, 0].set_ylim(None, 2.4)
    # vmaxAbs = rf_sym_range(rfTempLE['rf'])
    ax[1, 1].pcolormesh(wavelengthEdgesLE - lambda0, cfnData['heightEdges'], rfTempLE['rf'],
                        rasterized=True, cmap='RdBu_r',
                        norm=SymLogNorm(linthresh=1e-14, vmin=-vmaxAbs, vmax=vmaxAbs))
    ax[1, 1].plot(cfnData['wavelengthTau1'], cfnData['tau1LE'], c='r', alpha=0.5)
    ax[1, 1].set_xlim(-0.1, 0.1)
    ax[1, 1].set_ylim(None, 2.4)
    # vmaxAbs = rf_sym_range(rfVlosLI['rf'])
    ax[1, 2].pcolormesh(wavelengthEdgesLE - lambda0, cfnData['heightEdges'], rfVlosLE['rf'],
                        rasterized=True, cmap='RdBu_r',
                        norm=SymLogNorm(linthresh=1e-14, vmin=-vmaxAbs, vmax=vmaxAbs))
    ax[1, 2].plot(cfnData['wavelengthTau1'], cfnData['tau1LE'], c='r', alpha=0.5)
    ax[1, 2].set_xlim(-0.1, 0.1)
    ax[1, 2].set_ylim(None, 2.4)

    axFlat = ax.ravel()
    for i in range(axFlat.shape[0]):
        if not (i == 0 or i == 3):
            axFlat[i].set_yticklabels([])
        else:
            axFlat[i].set_ylabel('Height [Mm]')

        if i < 3:
            axFlat[i].set_xticklabels([])
        else:
            axFlat[i].xaxis.set_major_locator(MaxNLocator(3))
            axFlat[i].set_xlabel(r'$\Delta\lambda$ [nm]')
    return fig

def read_rfs(folder, stepIdx, dt=1e-3):
    with open(chRT.data_file(folder + '/Rfs/LI/' + 'Rf_temp_5.00e+01_{:.2e}_{:d}.pickle'.format(dt, stepIdx)), 'rb') as pkl:
        rfTempLI = pickle.load(pkl)

    with open(chRT.data_file(folder + '/Rfs/LI/' + 'Rf_vlos_2.00e+01_{:.2e}_{:d}.pickle'.format(dt, stepIdx)), 'rb') as pkl:
        rfVlosLI = pickle.load(pkl)

    with open(chRT.data_file(folder + '/Rfs/LE/' + 'Rf_temp_5.00e+01_{:.2e}_{:d}.pickle'.format(dt, stepIdx)), 'rb') as pkl:
        rfTempLE = pickle.load(pkl)

    with open(chRT.data_file(folder + '/Rfs/LE/' + 'Rf_vlos_2.00e+01_{:.2e}_{:d}.pickle'.format(dt, stepIdx)), 'rb') as pkl:
        rfVlosLE = pickle.load(pkl)

    wavelengthLI = np.load(chRT.data_file(folder + '/Rfs/LI/Wavelength.npy'))
    wavelengthLE = np.load(chRT.data_file(folder + '/Rfs/LE/Wavelength.npy'))

    return rfTempLI, rfVlosLI, rfTempLE, rfVlosLE, wavelengthLI, wavelengthLE

timesToPlot = [11, 20]
for i, t in enumerate(timesToPlot):
    stepIdx = np.searchsorted(atmost.time, t)
    rfs = read_rfs('Flat1e9NoIncRad', stepIdx)
    fig = plot_cf_rf_comparison(F9Cfns[i], *rfs)
    lFig  = chRT.save_figure('F9RfComp{:d}s'.format(t), fig, fext='.pgf', dpi=500)
    if i == 0:
        lFig.caption = r'Comparative plots of the temperature and velocity response functions and the contribution function for the Ca\,\textsc{{ii}} \SI{{854.2}}{{\nano\metre}} line in the F9 simulation at $t=\SI{{{:d}}}{{\second}}$. The upper row shows the LI treatment, and the lower row the LE treatment. For the response functions, enhancement to a positive perturbation is shown in red, and reduction in blue. The same colour scale is used in all response function panels, and $\tau_\nu=1$ altitude is overlaid on each plot.'.format(t)
        lFig.placement = 'tb'
    else:
        lFig.caption = r'Comparative plots of the response and contribution functions, equivalent to Fig.~\ref{{Fig:F9RfComp11s}} for the F9 simulation at $t=\SI{{{:d}}}{{\second}}$.'.format(t)
        lFig.placement = 'p'
    lFig.short_caption = r'Comparison of contribution, temperature response, and velocity response functions for the F9 simulation at $t=\SI{{{:d}}}{{\second}}$.'.format(t)

for i, t in enumerate(timesToPlot):
    stepIdx = np.searchsorted(atmostF10.time, t)
    rfs = read_rfs('Flat1e10NoIncRad', stepIdx)
    fig = plot_cf_rf_comparison(F10Cfns[i], *rfs)
    lFig  = chRT.save_figure('F10RfComp{:d}s'.format(t), fig, fext='.pgf', dpi=500)
    lFig.caption = r'Comparative plots of the response and contribution functions, equivalent to Fig.~\ref{{Fig:F9RfComp11s}} for the F10 simulation at $t=\SI{{{:d}}}{{\second}}$.'.format(t)
    lFig.short_caption = r'Comparison of contribution, temperature response, and velocity response functions for the F10 simulation at $t=\SI{{{:d}}}{{\second}}$.'.format(t)
    lFig.placement = 'p' if i == 0 else 'tbp'

def plot_stat_eq_rf_comp(cfnData, rfTimeDep, rfStatEqCc, rfStatEqNeFix,
                         wavelengthLI):
    fig, ax = plt.subplots(1, 3, figsize=texfigure.figsize(pytex, scale=1, height_ratio=0.4))
    fig.subplots_adjust(bottom=0.16, left=0.12, right=0.99, wspace=0.12)

    wavelengthEdgesLI = np.concatenate(([wavelengthLI[0]],
                                        0.5 * (wavelengthLI[1:] + wavelengthLI[:-1]),
                                        [wavelengthLI[-1]]))

    ca = CaII()
    lambda0 = ca.lines[-1].lambda0

    vmaxAbs = rf_sym_range(rfTimeDep['rf'])
    ax[0].pcolormesh(wavelengthEdgesLI - lambda0, cfnData['heightEdges'], rfTimeDep['rf'],
                        rasterized=True, cmap='RdBu_r',
                        norm=SymLogNorm(linthresh=1e-14, vmin=-vmaxAbs, vmax=vmaxAbs))
    # ax[0].plot(cfnData['wavelengthTau1'], cfnData['tau1LI'], c='r', alpha=0.5)
    ax[0].set_xlim(-0.1, 0.1)
    ax[0].set_ylim(None, 2.4)
    ax[0].set_title('Time-Dependent')
    # vmaxAbs = rf_sym_range(rfVlosLI['rf'])
    ax[1].pcolormesh(wavelengthEdgesLI - lambda0, cfnData['heightEdges'], rfStatEqCc['rf'],
                        rasterized=True, cmap='RdBu_r',
                        norm=SymLogNorm(linthresh=1e-14, vmin=-vmaxAbs, vmax=vmaxAbs))
    # ax[1].plot(cfnData['wavelengthTau1'], cfnData['tau1LI'], c='r', alpha=0.5)
    ax[1].set_xlim(-0.1, 0.1)
    ax[1].set_ylim(None, 2.4)
    ax[1].set_title('SE, Charge Cons.')

    ax[2].pcolormesh(wavelengthEdgesLI - lambda0, cfnData['heightEdges'], rfStatEqNeFix['rf'],
                        rasterized=True, cmap='RdBu_r',
                        norm=SymLogNorm(linthresh=1e-14, vmin=-vmaxAbs, vmax=vmaxAbs))
    # ax[2].plot(cfnData['wavelengthTau1'], cfnData['tau1LI'], c='r', alpha=0.5)
    ax[2].set_xlim(-0.1, 0.1)
    ax[2].set_ylim(None, 2.4)
    ax[2].set_title('SE, Fixed $n_e$')

    axFlat = ax.ravel()
    for i in range(axFlat.shape[0]):
        if not (i == 0):
            axFlat[i].set_yticklabels([])
        else:
            axFlat[i].set_ylabel('Height [Mm]')

        axFlat[i].xaxis.set_major_locator(MaxNLocator(3))
        axFlat[i].set_xlabel(r'$\Delta\lambda$ [nm]')

    return fig

def read_se_comp_rfs(folder, stepIdx, dt=1e-3):
    with open(chRT.data_file(folder + '/Rfs/LI/' + 'Rf_temp_5.00e+01_{:.2e}_{:d}.pickle'.format(dt, stepIdx)), 'rb') as pkl:
        rfTimeDep = pickle.load(pkl)

    # NOTE(cmo): Forgive the awful convention: timestep 1e10 is charge cons stat
    # eq, 1e11 is fixed ne
    with open(chRT.data_file(folder + '/Rfs/LI/' + 'Rf_temp_5.00e+01_{:.2e}_{:d}.pickle'.format(1e10, stepIdx)), 'rb') as pkl:
        rfCc = pickle.load(pkl)

    with open(chRT.data_file(folder + '/Rfs/LI/' + 'Rf_temp_5.00e+01_{:.2e}_{:d}.pickle'.format(1e11, stepIdx)), 'rb') as pkl:
        rfNeFix = pickle.load(pkl)

    wavelengthLI = np.load(chRT.data_file(folder + '/Rfs/LI/Wavelength.npy'))
    return rfTimeDep, rfCc, rfNeFix, wavelengthLI

stepIdx = np.searchsorted(atmostF10.time, 11.0)
rfs = read_se_comp_rfs('Flat1e10NoIncRad', stepIdx)
fig = plot_stat_eq_rf_comp(F10Cfns[0], *rfs)
lFig = chRT.save_figure('StatEqRfComparison', fig, fext='.pgf', dpi=500)
lFig.caption = r'Comparison of time-dependent and statistical equilibrium response functions for the \CaLine{} line in the F10 simulation at $t=\SI{11}{\s}$. The time-dependent response function is computed with a timestep of \SI{1}{\milli\s}. The middle column shows the statistical equilibrium response function when charge conservation is considered, and the right-hand column the statistical equilibrium response function when the hydrogen populations and electron density are held fixed.'
lFig.short_caption = r'Comparison of time-dependent and statistical equilibrium response functions.'
lFig.placement = 'tbp'
\end{pycode}

% spell-checker: enable

In Section~\ref{Sec:TimeDep8542Profiles} the contribution function was used to investigate the effects of the LI treatment on the \CaLine{} line.
It may be possible to obtain greater interpretability through the use of response functions (as introduced in Sec.~\ref{Sec:IntroRfs}), but to our knowledge these have only been considered for models in statistical equilibrium.
\citet{Carlsson2002} investigated the settling times for hydrogen ionisation in \Radyn{} simulations by applying a perturbative numerical formulation similar to that we will apply in computing time-dependent response function.

For the time-dependent situation, we perturb an atmospheric parameter at a particular depth as before, and then a timestep by which to advance the system is needed.
This should be short compared to the hydrodynamic evolution of our system, but sufficiently long to allow the population change to rise above our convergence threshold and correctly converge to the new solution.
In essence, we are computing the time-dependent response function $\mathcal{R}_{\nu, q,t}$ as the response function $\mathcal{R}_{\nu, q}$ after a time $\Delta t$ has elapsed.
As discussed in Sec.~\ref{Sec:IntroRfs}, a centred finite-difference method in the perturbed parameter is applied, i.e.
\begin{equation}
\begin{aligned}
    \mathcal{R}_{\nu, q, t}(k, t) &= \mathcal{R}_{\nu, q}(k) \bigg|_{t + \Delta t}\\
    &= \frac{I(\nu, q_k + \delta q /2, t + \Delta t) - I(\nu, q_k - \delta q / 2, t+\Delta t)}{\delta q}.
\end{aligned}
\end{equation}

\citet{Carlsson2002} and \citet{Judge2005} note that for a two level atom a population perturbed out of statistical equilibrium will follow an exponential decay back to the steady state solution, further supporting the choice of a short timestep to attempt to remain within the more ``linear'' regime of this process.
The NLTE multilevel system is more complex and theoretically depends on the eigenvalue spectrum of the rate matrix.
In the analysis of \citet{Carlsson2002} the full rate matrix was found to significantly underestimate the ionisation relaxation time, and NLTE effects slowed the population evolution.
\citet{Judge2005} applied a simplified variant of the mathematical framework of \citet{Gayley1990} showing how, at high optical depths, NLTE radiative transfer effects can reduce the radiative decay rate.
Extreme care should be taken when trying to make quantitative use of these time-dependent response functions, especially for longer timesteps, but for now we shall focus on qualitative aspects.

\py[TimeDepRT]|chRT.get_figure('F9RfComp11s')|

Time-dependent response functions were computed for perturbations in temperature and velocity to the same atmospheres for which the contribution functions were considered in Section~\ref{Sec:TimeDep8542Profiles}.
These properties were chosen as they are important but ``relatively'' free parameters in the system.
It is also common to compute the response functions to electron density, microturbulent velocity and magnetic field, however these parameters are either not considered or not truly free.
Following \Radyn{}, the microturbulence is assumed to be constant both in time and throughout the atmosphere, and this model does not consider any effects of the magnetic field.
For the LI model, the electron density is dependent on the rest of the atmosphere through charge conservation, and is therefore not a free parameter.
In the LE case, where the hydrogen populations are considered fixed over each timestep, the electron density is also held fixed over the duration of the response functions.
We note that the radiative response to the electron density could likely be computed following \citet{Metcalf1990a} who present the following method for computing the response to electron density $n_e$
\begin{equation}
    \frac{\partial I}{\partial n_e} = \left( \frac{\dd{}I}{dT} - \frac{\partial I}{\partial T} \right)\left( \frac{\dd{}n_e}{dT} \right)^{-1},
\end{equation}
where these terms are defined as follows: the total derivative of $I$ with respect to $T$ can be evaluated from computing the response with charge conservation enabled, the partial derivative of $I$ with respect to $T$ from computing the response with $n_e$ fixed, and the derivative of $n_e$ with respect to $T$ can simply be computed from the change in $n_e$ during evaluation of the response function with charge conservation.
This method was originally presented for computing the response of an intermediate parameter such as the source function or opacity to $n_e$, but there is no reason why it cannot be applied directly to intensity.
In the context of inversions, this additional response is very useful, however our RHD models should normally remain self-consistent.
Nevertheless, this could also be useful for interpretation, but is $\sim2\times$ more computationally costly than other parameters due to the requirement of additional derivatives.

\py[TimeDepRT]|chRT.get_figure('F9RfComp20s')|
\py[TimeDepRT]|chRT.get_figure('F10RfComp11s')|

\py[TimeDepRT]|chRT.get_figure('F10RfComp20s')|

Our contribution and response functions are shown in Fig.~\ref{Fig:F9RfComp11s} -- \ref{Fig:F10RfComp20s} (LI in the upper rows and LE in the lower).
In the response function plots red shows an enhancement in outgoing radiation as a response to an increase in the perturbed parameter at the particular depth, whereas blue indicates a reduction.
The same colour scale is used for all response function panels.
All of the response functions shown in these plots were computed with a timestep of \SI{1}{\milli\second}, but were visually identical to those computed for a timestep of \SI{10}{\milli\second} and extremely similar to those computed for a timestep of \SI{0.1}{\milli\second}.
Substantial differences appeared for a timestep of \SI{1}{\micro\s}, possibly due to convergence issues, as the populations have little time to evolve over such a short timestep, making it difficult to judge convergence to the necessary level.
The stability of the response across these three timesteps suggests we are capturing a physical response, rather than the numerics of the method.

The shape of the temperature response function is immediately recognisable as similar to the contribution function shown in the first column.
This is not surprising, as temperature is the most important atmospheric parameter in spectral line formation, and will always affect the region where the observed photons form.
Nevertheless, at a particular wavelength, temperature response features can be seen at greater depth (well below the $\tau_\nu=1$ line) than any in the contribution function, as a change in radiation field at this depth can affect the radiative rates in the line-forming region.

The other immediately remarkable feature present in all of the temperature response functions shown here is the presence of a negative response to temperature above $\sim$\SI{1.2}{\mega\metre} (i.e. an increase in temperature in this region decreases the outgoing intensity).
This is due to a reduction in the local source function, primarily due to an increase in the populations of the lower level of this transition: below \SI{1.4}{\mega\m} this reduces the strength of the line core, whereas above this region this reduction is due to an increase in opacity, trapping radiation in the atmosphere, and creating a dip in the line profile.
This same region is simply shown as contributing in the contribution function panels and tends to be more pronounced in models with the LE treatment, where the $\tau_\nu=1$ line is at a higher altitude.

There is a narrow blue bar in the line core of the LI temperature response function of Fig.~\ref{Fig:F9RfComp11s} around \SI{0.25}{\mega\metre}.
This is likely an artefact of the numerical method used to compute the response function, although it also appears for the other timesteps used to verify the response function.
When a feature like this appears only for one depth point it is usually a spurious numerical artefact, and we will discount it in the following.

In the right-most column of these figures we have plotted the velocity response function.
The structure of this plot below $\sim$\SI{1}{\mega\metre} is easy to interpret; an increase in velocity shifts the line-core towards bluer wavelengths, and away from redder wavelengths.
The effects on the far wings, visible below $\sim$\SI{0.4}{\mega\metre} are less immediately intuitive, but are very small variations corresponding to increased absorption of photospheric emission in the blue wing, and reduced absorption in the red wing, due to the far wings of the line profile.
The structure in the line core is far more complex, and has a non-trivial response to variations in velocity, affecting the LE and LI cases differently.
This is most pronounced in the F10 response function at \SI{11}{\second} (Fig.~\ref{Fig:F10RfComp11s}).
There are also responses due to changes in velocity from well below the $\tau_\nu=1$ level in the line core which produce changes in opacity in these regions affecting the radiation field in the line forming region.

The difficulties of a quantitative analysis become clear when looking at the scales of two different LI temperature response functions from the F10 simulation at $t=\SI{11}{\s}$.
Normalising the response to the line profile, for a timestep of \SI{10}{\milli\s} the maximum response in the \CaLine{} line was $8.84\times{}10^{-5}\,\si{\per\kelvin}$, and for
a timestep of \SI{0.1}{\milli\s} this was $8.86\times{}10^{-5}\,\si{\per\kelvin}$.
The consistency of these values and the response functions suggests that the evolution is occurring on a timescale $\leq \SI{0.1}{\milli\s}$.
This is not overly surprising given the conclusions of Sec.~\ref{Sec:TimeDepSE}, where a statistical equilibrium treatment was found to adequately reproduce the full time-dependent evolution of the calcium populations at most points in the model presented.
This consistency poses problems to recasting these response functions as a fractional change in the line profile per unit time, as the model with the shorter timestep would appear to have a response two orders of magnitude larger than the smaller one.

More interestingly, the \Ha{} response function computed for these two timesteps was also found to be almost identical, despite the accepted need for a time-dependent treatment.
It is probable that we are seeing results similar to those of \citet{Leenaarts2012a}, who found that for RMHD simulations \Ha{} can be synthesised correctly in statistical equilibrium if the equation of state takes into account non-equilibrium ionisation.

\py[TimeDepRT]|chRT.get_figure('StatEqRfComparison')|

This leads to the question of whether it is possible to employ statistical equilibrium response functions in these simulations.
These are compared both with and without charge conservation to the time-dependent temperature response function for the \CaLine{} line in the F10 atmosphere at $t=\SI{11}{\s}$ in Fig.~\ref{Fig:StatEqRfComparison}.
The left-hand panel once again shows the time-dependent response function computed with a timestep of \SI{1}{\milli\s}, the centre panel shows a statistical equilibrium response function, including hydrogen evolution and charge conservation, while the right-hand panel shows a statistical equilibrium response function computed whilst holding the hydrogen populations and electron density fixed.
Immediately we see a large difference between the middle panel and the other two.
This is due to the hydrogen populations, and more specifically its ionisation state, relaxing back to the statistical equilibrium solution.
The information presented on this middle panel is not equivalent to the left-hand panel, showing responses in the line core at locations both deeper and shallower than those found in the time-dependent solution.
The right-hand panel (holding the hydrogen populations and electron density fixed) agrees better with the time-dependent response function, but there are still significant differences in the structure above \SI{1.2}{\mega\metre}, with additional positive responses appearing.
It was found that running the time-dependent response functions for long timesteps ($>\SI{100}{\s}$), started to produce similar structure, although these did not converge to the same result.
It may be acceptable to use this second form of statistical equilibrium response function to diagnose the \CaLine{} response in RHD simulations, but it typically took longer to converge than the time-dependent approach, and cannot be generalised to compute response functions of hydrogen lines, due to these populations being held fixed.
\added{The difference between the time-dependent and statistical equilibrium with fixed electron density response functions is qualitatively similar in the F9 simulation and at other times in this simulation, although at later times ($t \gtrsim \SI{35}{\s}$), as the populations settle the differences are reduced in both simulations.}

The time-dependent response functions discussed here are a more NLTE-motivated approach to the problem of spectral line formation in RHD simulations.
They allow the identification of the regions and parameters to which the line is sensitive (which may be due to non-local radiative effects), and show whether a change in a parameter will provoke a positive or negative response on the outgoing radiation.
This differentiates response functions from the contribution function by showing the negative response to temperature above $\sim\SI{1.2}{\mega\m}$.
Response functions can also be used to separate the effects of different parameters in these models, a feature that will likely become increasingly important as the complexity of flare modelling increases further.
We stress that as response functions represent a local gradient, they are only valid in small parameter regions around those the model was computed with.
The time-dependent formalism presented here will need additional development for quantitative uses, but we feel that it already provides information complementary to the contribution function and are optimistic about future applications to improve the interpretation of line formation in RHD simulations

\section{Discussions}

We have presented multiple applications of the \Lw{} framework to reprocessing the radiative transfer of \Radyn{} simulations.
Through the construction of simple tools, we are able to quantitatively investigate the importance of various radiative effects that may not be considered in \Radyn{}'s treatment (but without modifying the energy balance or hydrodynamics), more rapidly than would be possible incorporating the necessary changes into \Radyn{}.
These tools have been used to investigate the effects of photoionisation of \Caii{} to \Caiii{} by the hydrogen Lyman lines, the importance of treating the \Caii{} populations with time-dependence, and the possible difficulties in applying a PRD treatment in RHD simulations.

From the flare simulations presented here the hydrogen Lyman lines have significant effects on the \Caii{} photoionising radiation field.
This results in substantial changes in both the outgoing \CaLine{} line profiles, and the radiative energy balance in the upper chromosphere.
The radiative losses in this region were found to be affected by up to 15\%, which could in turn lead to differences in the hydrodynamic evolution of the simulation and thus greater difference in the line profiles.
We did not find a clear correlation between the magnitude of this effect and the increased heating in the F9 and F10 models: in both cases the effect was important, and therefore is likely to remain so at higher energy depositions.
It is therefore essential that RHD simulations start to consider this in a self-consistent way to gauge its full effect.
These photoionisation effects could also affect other species with continua overlapping the hydrogen Lyman lines.
For instance, Mg\,\textsc{ii} line profiles are often used for chromospheric diagnostics, but these are unlikely to be as significantly affected by the hydrogen Lyman lines as \Caii{} due to the resonance continuum edge being located at \SI{82.46}{\nano\metre}, which can therefore only be affected by the far Lyman continuum.
The Mg\,\textsc{ii} populations will be influenced to a lesser extent by photoionisation from the subordinate continua, some of which overlap the Lyman series.

On the other hand, we found that the deviations of the calcium populations due to full time-dependent kinetic equilibrium over statistical equilibrium were typically small in the simulations investigated.
This is interesting, as it theoretically allows for \Caii{} to be processed separately, but as the radiative losses from this species need to be known for the hydrodynamics of an RHD simulation, this species likely still needs to be treated in lockstep with the rest of the simulation.
Additionally, there is typically a loss in speed by computing the statistical equilibrium solution at each timestep in the simulation (even starting close to the solution from the previous timestep's solution) over the time-dependent solution when using traditional radiative transfer methods.
This could change with the application of machine learning, as it will be far easier to construct detailed models that provide the unique statistical equilibrium solution for a given atmosphere than determining the correct time-dependent solution.
As the hydrogen populations would continue to require a full time-dependent treatment there is not likely to be an immediate gain from such a model in the context of RHD simulations.
However, the nuanced analysis of the formation of H$\alpha$ in the quiet Sun by \citet{Leenaarts2012a} suggests that it may be sufficient to purely capture the effects of hydrogen non-equilibrium ionisation (i.e. the fraction of hydrogen that is fully ionised and its effects on the electron density) through the equation of state and then perform NLTE synthesis in statistical equilibrium with this given electron density.
This would also need to be validated for flare models, which could be done following the approach laid out in this chapter.
It would then become significantly easier to apply machine learning models to these separable components; this could provide massive computational gains in RHD modelling, whilst detailed spectral synthesis would remain possible through traditional NLTE radiative transfer approaches.
Parallels can be drawn between the application of machine learning to this problem and the use of simplified local rates following the method of \citet{Sollum1999} as used in HYDRAD \citep{Reep2019}, and BIFROST \citep{Gudiksen2011, Leenaarts2007}, but it remains to be proven whether this method retains sufficient accuracy at the high energy depositions that occur in flares.

Despite the apparent simplicity of incorporating PRD into these tools, the iteration process was plagued with convergence problems that we have been unable to fully resolve.
Nevertheless, for the hydrogen Lyman lines in the F9 simulation presented in this chapter, the Doppler-like PRD approximations currently present in \Radyn{} perform well, and come at no additional computational cost over the basic CRD treatment, validating the quiet Sun results of \citet{Leenaarts2012a}.
We therefore recommend that this approximation continue to be employed for Ly$\alpha$ and Ly$\beta$ until more advanced iteration methods are developed and implemented (that can simultaneously efficiently solve for the atomic level populations, electron density, and necessary PRD line emission profile ratios), although it would be good to test the quality of this approximation in more strongly heated atmospheres.

It is possible to apply the method outlined in Sec.~\ref{Sec:TimeDepPrd} to Mg\,\textsc{ii}, but it is likely, as shown by \citet{Kerr2019}, that treating it in statistical equilibrium with PRD will provide a sufficiently accurate solution whilst remaining relatively efficient, hopefully allowing this species to be incorporated into RHD simulations in the near future.
It is also important to investigate other effects that may change the formation of these spectral lines.
For example, \citet{Zhu2019}, used an improved Stark broadening treatment when synthesising Mg\,\textsc{ii} h \& k from snapshots of a \Radyn{} model in RH.
They found that a 30$\times$ increase in Stark broadening (or the equivalent increase in another Lorentzian broadening term) was needed to reproduce observations.
Additionally, \citet{Kowalski2017a} note that a correct treatment of Mg\,\textsc{ii} requires the modelling of overlapping bound-bound transitions, which is not possible with current RHD codes, but does not pose any great computational difficulty in theory.

The effects of treating the \Caii{} resonance lines in PRD were significantly larger than those seen with the hydrogen Lyman lines.
This is seen not only in the line profiles, but also in the chromospheric radiative losses in these lines, which vary substantially when treated with PRD (and are typically smaller than those computed in CRD, as found previously in wave-heated atmospheres by \citet{Uitenbroek2002}).
It is therefore important to investigate whether applying PRD to the H and K lines can be done efficiently.
Empirically, we have found that the majority of convergence problems originate from the hydrogen Lyman lines, thus it may be relatively efficient to treat the \Caii{} resonance lines in PRD.
If similar convergence issues also affect these lines, then it would be desirable to devise and implement an approximation scheme similar to that used for Ly$\alpha$ and Ly$\beta$.
As previously mentioned, it has been suggested that \Radyn{}'s treatment of the \Caii{} resonance lines in CRD overestimates the radiative losses but this overestimation is compensated by not considering the Mg\,\textsc{ii} h and k lines \citep[e.g.][]{Carlsson2002,Kerr2019a}.
The techniques presented in this chapter should allow for a thorough investigation of this assumption and the development of suitable PRD approximations if necessary.

\added{
In summary, we found that it is essential to consider the photoionising effects of the Lyman lines when modelling the \Caii{} lines in flares, but a statistical equilibrium treatment of the \Caii{} level populations appears to be sufficient in general.
Considering PRD effects, we found that the Doppler-like approximation used in \Radyn{} appears accurate for Ly$\alpha$ and Ly$\beta$, and similar approximations should be investigated for the \Caii{} resonance lines, as their line profiles and radiative losses vary dramatically between PRD and CRD treatments (as previously remarked by \citet{Uitenbroek2002} in wave-heated chromospheric simulations).
}