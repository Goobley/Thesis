\chapter{Two-Dimensional Radiative Transfer}

% \begin{itemize}
%     \item Adding a dimension to RT, formal solver etc.
%     \item Simulation setup.
%     \item Analysis.
%     \item Suggestions on visibility of this chromospheric glow with DKIST.
% \end{itemize}

All of the theory of radiative transfer discussed in previous chapters remains valid when applied to higher dimensional systems, with the exception of the formal solver.
This is due to the non-local terms that appear within the MALI description (with diagonal $\Lambda$ operator) being handled by formal solver, which is responsible for computing the radiation field throughout the plasma from the local parameters and boundary conditions and thus coupling the atmospheric nodes.
Once the radiation field has been computed it is then used as a local parameter in the rest of the iteration.
In fact, if the storage for the atmosphere is ``flattened'' into a one-dimensional form, the code from the plane-parallel case can be used to implement the iteration scheme.

In this chapter we shall first describe the extension of the \Lw{} framework to two dimensions (with the possibility of further extension), and then describe its application to the simulation of a flaring atmosphere illuminating an adjacent slab of quiet sun, along with potential implications for future observations at high resolution.

\section{The Formal Solver in Two-Dimensions}

Similarly to the plane-parallel formal solver used in \Lw{}, described in the previous chapter, we use the short-characteristics method to compute the radiation field throughout the atmosphere.
This approach was first employed in two-dimensions by \citet{Auer1994} using a limited parabolic scheme to avoid overshoot.
We assume the following basis: the $z$-axis is oriented as in the plane-parallel case, oriented vertically from photosphere to corona, the $x$-axis is perpendicular and co-planar to the $z$-axis (in the plane of the page for the following diagrams), and by the right-hand rule the $y$-axis is oriented into the plane of the page.
In the two-dimensional case it is assumed that the atmospheric parameters are homogenous along the $y$-axis, but vary along the $x$- and $z$-axes.
We assume that the atmosphere has a fixed stratification in $x$ and $z$, and that the atmospheric parameters are known at each intersection of these grids.

The mean intensity at each point will be computed similarly to the plane-parallel case; by integration of the intensity over a weighted angular quadrature.
The Gauss-Legendre nodes used in the plane-parallel case are poorly suited to anisotropy that occurs in the two- and three-dimensional cases, and so we therefore employ the optimised quadratures of \citet{Stepan2020} in \Lw{}.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1.5, line width=1pt, >=latex]
    \def\xcoords{1,2,3.5,4,5}
    \def\xmax{5}
    \def\ycoords{1,2,2.5,3.5,5,6}
    \def\ymax{6}
    \def\raym{4/3}
    \def\rayc{-7/6}

    \draw [help lines]
    \foreach \y in \ycoords {
        (1, \y) -- (\xmax, \y)
    }
    \foreach \x in \xcoords {
        (\x, 1) -- (\x, \ymax)
    };
    \draw [<->] ({\xmax+0.5}, 1) node[below] {$x$} -- (1,1) -- (1, {\ymax+0.5}) node[left] {$z$};
    \coordinate (O) at (3.5, 3.5);
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=above left:{$O$}] at (O) {};
    \draw[->, domain=1.8:4.8, samples=10, thin] plot(\x, {\raym * (\x) + \rayc});
    \coordinate (D) at (4, {\raym * 4 + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{$D$}] at (D) {};
    \coordinate (U) at ({(2.5 - \rayc) / (\raym)}, 2.5);
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=above left:{$U$}] at (U) {};

    \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]above left:{\small $\alpha$}}] at (2, 2.5) {};
    \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]above right:{\small $\beta$}}] at (3.5, 2.5) {};
    \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]below right:{\small $\gamma$}}] at (4, 3.5) {};
    \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]above right:{\small $\delta$}}] at (4, 5) {};
\end{tikzpicture}
\caption{Diagram of short characteristics scheme in two-dimensions.}
\label{Fig:Sc2d}
\end{figure}

For each ray prescribed by the angular quadrature the formal solver must perform one sweep through the grid.
The general case, that of an inclined ray ray travelling through the atmosphere is shown in, Fig.~\ref{Fig:Sc2d}.
In the case of this ray the formal solver must sweep first along $x$ and then along $z$.
The points $U$ and $D$ refer to them being ``upwind'' and ``downwind'' of the point $O$ for which we are currently computing the intensity.
This can be explained by looking at the intersections of ray with the grid.
To compute the intensity in the direction of this ray at point $O$ using the short characteristics formulation we have
\begin{equation}\label{Eq:MiniScDefinition}
   I_O = I_U e^{-(\tau_U - \tau_O)} + \int_{\tau_O}^{\tau_U} S(t) e^{-(t - \tau_O)}\, dt,
\end{equation}
where these terms have their usual meanings, $I_O$ is the intensity in this direction at $O$, $I_U$ is the intensity in this direction at $U$ and we have dropped the angular and frequency dependencies for clarity.
Thus, to compute the intensity at $O$, the intensity at $U$ must first be known.
As $U$ does not typically lie on a point of our discrete two-dimensional grid, the value of $I_U$ (and other quantities) are not computed directly by the formal solver, and must instead be interpolated from the values of grid points along the line $\alpha\beta$.

Following the short characteristic method, a functional form must be assigned to the variation of $S$ over the the line segment $[UO]$.
In the simplest case, this can again be a linear functional form, but due to the additional axis for inhomogeneities that can be present in the two-dimensional case, unless the grid is very fine or the atmosphere very slowly varying, this may be a poor choice.
A higher order parametrisation of $S$ is likely to require the values of the source function at both $U$ and $D$, and possibly other points along this path.
Similarly to the cubic Bézier spline method used as standard in our plane-parallel code, we once again turn to monotonic Bézier splines for safe, smooth interpolation, minimising the presence of under and over-shoots.
The cubic method we apply in plane-parallel atmospheres requires four points along $UD$, which becomes less practical in higher dimensions, due to the large computational demands of the method.
Instead we choose the quadratic Bézier spline method, BESSER, of \citet{Stepan2013}, which will be briefly summarised here for the scalar case of the RTE.

\subsection{The BESSER method}

The BESSER method differs from other quadratic Bézier spline methods by ensuring the continuity of the first derivative of the interpolant at $O$.
Due to the large differences in optical depth between adjacent regions (e.g. $\tau_{UO}$ and $\tau_{OD}$) that are likely to occur in multi-dimensional cases with irregular grids, this method is designed so as to guarantee that if the values over $[UOD]$ are monotonic then the spline interpolant will remain monotonic.

The spline interpolant over the $[UO]$ interval is described by
\begin{equation}
    f(u) = (1-u)^2f_U + 2u(1-u)c_U + u^2f_O,\hspace{3em}u\in[0,1],
\end{equation}

where $f$ is the value of the parameter to be interpolated, $c_U$ is the functional value of the spline's control point, and $u$ is the normalised coordinate for the distance along $[UO]$.
The control points are points half way along an interval, defining the tangent to the spline at each end of the range i.e. $c_U O$ defines the tangent to the spline at $O$ and $U c_U$ defines the tangent to the spline at $U$.
If we denote the coordinates of our points along the ray $s_U$, $s_O$, and $s_D$ then we have $u = (s - s_U) / h_U$, where $h_U = s_U - s_O$.
An equivalent interpolation can be defined over the $[OD]$ segment.
The monotonicity (for monotonic $f_U$, $f_O$, $f_D$) and continuous first derivative of the interpolating functions at $O$ is ensured by
\begin{enumerate}
    \item Verify the monotonicity of $f_U$, $f_O$, $f_D$, and if $f_O$ is a local extremum then the control points $c_U$ and $c_D$ are set to $f_O$, giving a derivative of zero at $O$. As this is is the only possible solution for this case, the process stops here.

    \item Compute an estimate of the derivative at $O$, by using the derivative of the standard parabolic interpolation of $UOD$.

    \item Use this derivative to compute the initial values at the control points, by direct projection of the first derivative to their coordinates (as this defines a tangent to function at $O$).

    \item Check $c_U \in [f_U, f_O]$. If not, set $c_U$ to $f_U$ to correct for any new extremum and halt the process, as $c_D$ is not needed for the integration of the source function.

    \item Check $c_D \in [f_O, f_D]$. If not, set $c_D$ to $f_D$, and use this to compute a new value for the derivative at $O$, and follow the projection of this tangent to determine $c_U$ (due to the enforced continuity of the derivative at $O$).
\end{enumerate}
This process is described in more detail in \citet{Stepan2013}, but this covers the most important elements of the process.

\TODO{Do we modify to use the full value for $\tau_{OD}$?}
\TODO{Is this the correct what of expressing the difference between the control point, and the \emph{value} of the control point?}

Similarly to the plane-parallel case, we will solve the RTE in optical depth, due to its increased stability.
This interpolation method can be used to compute $\tau_{UO}$ and $\tau_{OD}$ by
\begin{align}
    \tau_{UO} &= \frac{1}{3}(\chi_U + \chi_O + \chi_{c_U}) (s_O - s_U),\\
    \tau_{OD} &= \frac{1}{2}(\chi_O + \chi_D) (s_D - s_O).
\end{align}
Note that a linear approximation was used for $\tau_{OD}$, as the previous process does not guarantee the calculation of $c_D$.
This could be modified to also use the quadratic spline method, which may be more robust, however the value of $\tau_{OD}$ rarely affects the final solution dramatically.

This method can now be applied to the source function but parametrised along $\tau$ rather that $s$.
The BESSER quadratic spline method is then used to compute the value of the source function control point $S_{c_U}$.
The integral in \eqref{Eq:MiniScDefinition} can now be evaluated, by using the prescribed quadratic spline variation of $S$ over the interval $[\tau_{U}, \tau_{O}]$.
Working through the maths we arrive at
\begin{equation}
    I_D = I_Ue^{-\tau_{UO}} + \omega_U S_U + \omega_O S_O + \omega_{c_U} S_{c_U},
\end{equation}
where,
{
\def\edt{e^{-\tau_{UO}}}
\def\tsq{\tau_{UO}^2}
\begin{align}
    \omega_U &= \frac{2 - (\tsq + 2\tau_{UO} + 2)\edt}{\tsq},\\
    \omega_O &= 2\frac{\tau_{UO} - 2 + \edt (\tau_{UO} + 2)}{\tsq},\\
    \omega_{c_U} &= 1 - 2 \frac{\edt + \tau_{UO} - 1}{\tsq}.
\end{align}
}

For small values of $\tau_{UO}$ the numerical precision of the exponential function becomes unreliable (in floating point arithmetic), so for this reason these are replaced with Taylor expansions for $\tau_{UO}\lesssim 0.1$.

An expression for the $\Lambda^*$ operator can then be devised equivalently to the process used previously.
The source function is locally set to unity, and zero elsewhere.
This implies that $c_U$ is also set to 1.
Thus the local contribution to the radiation field is given by
\begin{equation}
    \Lambda^*(\nu, \vec{d}) = \omega_{c_U} + \omega_O,
\end{equation}
and remains related to $\Psi^*$ by the local opacity.

The equivalent integration and $\Lambda$ operator coefficients for a linear short characteristics approach can be computed similarly and are analagous to those computed in the one-dimensional case.

\TODO{Discuss with Ivan on the exact form of $\Psi^*$ when the contributions to $\Lambda^*$ are not strictly local.}

\subsection{Evaluation Order and Boundary Conditions}

Looking more closely at the order in which the formal solver needs to sweep the grid, we can see that $O$ for the ray discussed in the previous section and shown in Fig.~\ref{Fig:Sc2d} would be the 10th node to be solved, and this ordering is shown in Fig.~\ref{Fig:2DSweep}.
Most of the nodes on this figure are solved equivalently to this one, with all necessary quantities known provided the sweep order is preserved, but there are several question marks which require explanation.

The {\color{TolBlue} blue} question marks along the $x$ axis all require values that must be computed from the boundary conditions.
The upper and lower boundary conditions in $z$ are typically taken to be described by a defined radiation field (possibly based on a black body).
The upper and lower boundaries in $x$ can be described by fixed boundary conditions, but it is also common to describe these with periodic boundary conditions where the ray wraps from one side of the grid to the other.
The {\color{TolTeal} teal} question marks along the upper $x$ boundary can be interpreted in multiple ways; in the case of periodic boundary conditions they can be prolonged along the {\color{TolTeal} teal} arrows, and used in the same way as the previously described case.
If fixed boundary conditions are used then the intensity at these points must be computed by a linear formal solver indicated by the black arrows ending at the nodes labelled 4 and 8.

\TODO{Explain orange question mark.}


\begin{figure}
\centering
\begin{tikzpicture}[scale=1.5, line width=1pt, >=latex]
    \def\xcoords{1,2,3.5,4,5}
    \def\xmax{5}
    \def\ycoords{1,2,2.5,3.5,5,6}
    \def\ymax{6}
    \def\raym{4/3}
    \pgfmathsetmacro\rayc{3.5 - \raym * 3.5}

    \draw [help lines]
    \foreach \y in \ycoords {
        (1, \y) -- (\xmax, \y)
    }
    \foreach \x in \xcoords {
        (\x, 1) -- (\x, \ymax)
    };

    \draw [<->] ({\xmax+0.5}, 1) node[below] {$x$} -- (1,1) -- (1, {\ymax+0.5}) node[left] {$z$};
    \coordinate (O) at (3.5, 3.5);
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=left:{\footnotesize 10}] at (O) {};
    \coordinate (D) at (4, {\raym * 4 + \rayc});
    % \node[circle, fill=black, inner sep=0 pt, minimum size=3pt] at (D) {};
    \coordinate (U) at ({(2.5 - \rayc) / (\raym)}, 2.5);
    \pgfmathsetmacro{\raystartx}{(2.5 - \rayc) / (\raym)}
    \pgfmathsetmacro{\rayendx}{4}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=10, thin] plot(\x, {\raym * (\x) + \rayc});
    % \node[circle, fill=black, inner sep=0 pt, minimum size=3pt] at (U) {};

    % (1,2) teal
    \pgfmathsetmacro\rayc{2 - \raym * 1}
    \def\raystarty{2}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{2.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin, color=TolTeal] plot(\x, {\raym * (\x) + \rayc});

    % (1,2.5) teal
    \pgfmathsetmacro\rayc{2.5 - \raym * 1}
    \def\raystarty{2.5}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{3.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin, color=TolTeal] plot(\x, {\raym * (\x) + \rayc});

    % (2,2)
    \pgfmathsetmacro\rayc{2 - \raym * 2}
    \def\raystarty{1}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{2.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{\footnotesize 1}] at (2,2) {};
    \node at (\raystartx, \raystarty) [below] {\color{TolBlue} ?};

    % (3.5,2)
    \pgfmathsetmacro\rayc{2 - \raym * 3.5}
    \def\raystarty{1}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{2.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=left:{\footnotesize 2}] at (3.5,2) {};
    \node at (\raystartx, \raystarty) [below] {\color{TolBlue} ?};

    % (4,2)
    \pgfmathsetmacro\rayc{2 - \raym * 4}
    \def\raystarty{1}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{2.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{\footnotesize 3}] at (4,2) {};
    \node at (\raystartx, \raystarty) [below] {\color{TolBlue} ?};

    % (5,2)
    \pgfmathsetmacro\rayc{2 - \raym * 5}
    \def\raystarty{1}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{2}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=left:{\footnotesize 4}] at (5,2) {};
    \node at (\raystartx, \raystarty) [below] {\color{TolBlue} ?};
    \node at (\rayendx, \rayendy) [right] {\color{TolTeal} ?};

    % (2,2.5)
    \pgfmathsetmacro\rayc{2.5 - \raym * 2}
    \def\raystarty{2}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{3.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{\footnotesize 5}] at (2,2.5) {};

    % (3.5,2.5)
    \pgfmathsetmacro\rayc{2.5 - \raym * 3.5}
    \def\raystarty{2}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    % \def\rayendy{3.5}
    % \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \def\rayendx{4}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=left:{\footnotesize 6}] at (3.5,2.5) {};

    % (4,2.5)
    \pgfmathsetmacro\rayc{2.5 - \raym * 4}
    \def\raystarty{2}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{3.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{\footnotesize 7}] at (4,2.5) {};

    % (5,2.5)
    \pgfmathsetmacro\rayc{2.5 - \raym * 5}
    \def\raystarty{2}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{2.5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=left:{\footnotesize 8}] at (5,2.5) {};
    \node at (\rayendx, \rayendy) [right] {\color{TolTeal} ?};

    % (2,3.5)
    \pgfmathsetmacro\rayc{3.5 - \raym * 2}
    \def\raystarty{2.5}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    \def\rayendy{5}
    \pgfmathsetmacro{\rayendx}{divide(\rayendy - \rayc,  \raym)}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{\footnotesize 9}] at (2,3.5) {};

    % (4,3.5)
    \pgfmathsetmacro\rayc{3.5 - \raym * 4}
    \def\raystarty{2.5}
    \pgfmathsetmacro{\raystartx}{divide(\raystarty - \rayc, \raym)}
    % \def\rayendy{4}
    \pgfmathsetmacro{\rayendx}{5}
    \pgfmathsetmacro{\rayendy}{\raym * \rayendx + \rayc}
    \draw[->, domain={\raystartx}:{\rayendx}, samples=3, thin] plot(\x, {\raym * (\x) + \rayc});
    \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{\footnotesize 11}] at (4,3.5) {};
    \node at (\raystartx, \raystarty) [above] {\color{TolOrange} ?};

\end{tikzpicture}
\caption{Diagram of sweep order in 2D}
\label{Fig:2DSweep}
\end{figure}

% \begin{figure}
% \centering
% \begin{tikzpicture}[scale=1.5, line width=1pt, >=latex]
%     \def\xcoords{1,2,3.5,4,5}
%     \def\xmax{5}
%     \def\ycoords{1,2,2.5,3.5,5,6}
%     \def\ymax{6}
%     \def\raym{0.6}
%     \pgfmathsetmacro\rayc{3.5 - \raym * 3.5}

%     \draw [help lines]
%     \foreach \y in \ycoords {
%         (1, \y) -- (\xmax, \y)
%     }
%     \foreach \x in \xcoords {
%         (\x, 1) -- (\x, \ymax)
%     };
%     \draw [<->] ({\xmax+0.5}, 1) node[below] {$x$} -- (1,1) -- (1, {\ymax+0.5}) node[left] {$z$};
%     \coordinate (O) at (3.5, 3.5);
%     \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=above left:{$O$}] at (O) {};
%     \draw[->, domain=1.2:4.8, samples=10, thin] plot(\x, {\raym * (\x) + \rayc});
%     \coordinate (D) at (4, {\raym * 4 + \rayc});
%     \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=right:{$D$}] at (D) {};
%     \coordinate (U) at ({(2.5 - \rayc) / (\raym)}, 2.5);
%     \node[circle, fill=black, inner sep=0 pt, minimum size=3pt, label=above left:{$U$}] at (U) {};

%     \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]above left:{\small $\alpha$}}] at (2, 2.5) {};
%     \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]above right:{\small $\beta$}}] at (3.5, 2.5) {};
%     \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]below right:{\small $\gamma$}}] at (4, 3.5) {};
%     \node[circle, fill=black, inner sep=0 pt, minimum size=2pt, label={[label distance=0.5mm]above right:{\small $\delta$}}] at (4, 5) {};
% \end{tikzpicture}
% \caption{Diagram of Short Characteristics Scheme in 2D}
% \label{Fig:Sc2d}
% \end{figure}

{\color{TolBlue} do the explanation/diagrams; boundary conditions!, vertical case}

{\color{Red} Need to cite linear, parabolic (Auer 94?), BESSER (stepan2013) Ibgui substepping}

\subsection{Substepping}

\subsection{Implementation Details}

From this description of the process, it is clear that there is a more complex ordering in which the atmospheric points must be visited than in the plane-parallel case (which can only be top--bottom or vice-versa).
In the case of a single-threaded program, it is sufficient to obey this order, however, when distributing work across threads or multiple computing nodes it is essential that the necessary information be present to avoid computation stalls, or the use of uninitialsed data.
There is an in-depth discussion of an advanced parallelisation algorithm for multi-dimensional radiative transfer in \citet{Stepan2013}, however in \Lw{} we assume that the entire simulation domain can be held in memory and the formal solver is parallelised in frequency, equivalently to the plane-parallel case.

The data structures for storing the atmospheric and population information in \Lw{} were also updated to support two dimensional atmospheres, storing the data contiguously so as to be able to reuse the core iteration machinery from the plane-parallel case (as inspired by the RH code).
Two-dimensional formal solvers can be loaded from external libraries via the same interface as used for their one-dimensional counterparts, and through these interfaces we ensure the modularity of \Lw{}.
An equivalent interface is also defined for the iteration function to be used in two-dimensions, giving flexibility in the interpolation order and any form of limiting used (which may need to be adapted to specific grids).
\Lw{} provides default implementations of the two-dimensional linear and BESSER short-characteristics formal solvers, along with linear and WENO4 interpolation schemes.

{\color{Red} Do we want a validation test here; can do in place.}